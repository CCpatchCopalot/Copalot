

The vulnerability stems from improper dimension updates when rotating image regions, leading to out-of-bounds reads. The critical modification is adding the `rot_image_params` flag to `rotateImage` calls to prevent toggling image dimensions unless rotating the entire image. The patch fixes this by setting `rot_image_params` to `FALSE` in `processCropSelections` when rotating individual regions, ensuring global image metadata remains consistent.

```diff
diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -7266,9 +7266,13 @@
                       (uint16_t)(image->adjustments & ROTATE_ANY));
             return (-1);
         }
-
-        if (rotateImage(rotation, image, &image->width, &image->length,
-                        work_buff_ptr, NULL))
+        /* Dummy variable to avoid switching image->width/length twice */
+        uint32_t width = image->width;
+        uint32_t length = image->length;
+        if (rotateImage(rotation, image, &width, &length,
+                        work_buff_ptr, NULL,
+                        TRUE))  /* TRUE = Update image params for full image */
         {
             TIFFError("correct_orientation", "Unable to rotate image");
             return (-1);
@@ -8635,7 +8639,8 @@
              * accordingly. */
             size_t rot_buf_size = 0;
             if (rotateImage(crop->rotation, image, &crop->combined_width,
-                            &crop->combined_length, &crop_buff, &rot_buf_size))
+                            &crop->combined_length, &crop_buff, &rot_buf_size,
+                            FALSE))  /* FALSE = Don't update main image params */
             {
                 TIFFError("processCropSelections",
                           "Failed to rotate composite regions by %" PRIu32
@@ -8759,10 +8764,10 @@
                  * its size individually. Therefore, seg_buffs size needs to be
                  * updated accordingly. */
                 size_t rot_buf_size = 0;
-                if (rotateImage(
-                        crop->rotation, image, &crop->regionlist[i].width,
-                        &crop->regionlist[i].length, &crop_buff, &rot_buf_size))
-                {
+                if (rotateImage(crop->rotation, image,
+                                &crop->regionlist[i].width,
+                                &crop->regionlist[i].length, &crop_buff,
+                                &rot_buf_size, FALSE))  /* FALSE = Region rotation */
                     TIFFError("processCropSelections",
                               "Failed to rotate crop region by %" PRIu16
                               " degrees",
@@ -8905,7 +8910,7 @@
         CROP_ROTATE) /* rotate last as it can reallocate buffer */
     {
         if (rotateImage(crop->rotation, image, &crop->combined_width,
-                        &crop->combined_length, crop_buff_ptr, NULL))
+                        &crop->combined_length, crop_buff_ptr, NULL, TRUE))
         {
             TIFFError("createCroppedImage",
                       "Failed to rotate image or cropped selection by %" PRIu16
``` 

This diff shows the key call site changes where the `rot_image_params` flag was added to control dimension updates. The `FALSE` argument in `processCropSelections` (lines 8639/8764) prevents invalid metadata changes during region rotation, directly mitigating the out-of-bounds read.