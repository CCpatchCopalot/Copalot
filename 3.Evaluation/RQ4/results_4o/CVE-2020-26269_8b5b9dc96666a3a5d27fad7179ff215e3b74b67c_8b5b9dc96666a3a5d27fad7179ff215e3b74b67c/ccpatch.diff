diff --git a/tensorflow/core/platform/file_system_helper.cc b/tensorflow/core/platform/file_system_helper.cc
--- a/tensorflow/core/platform/file_system_helper.cc
+++ b/tensorflow/core/platform/file_system_helper.cc
@@ -163,29 +163,29 @@
   // To expand the globbing, we do a BFS from `dirs[matching_index-1]`.
   // At every step, we work on a pair `{dir, ix}` such that `dir` is a real
   // directory, `ix < dirs.size() - 1` and `dirs[ix+1]` is a globbing pattern.
   // To expand the pattern, we select from all the children of `dir` only those
   // that match against `dirs[ix+1]`.
   // If there are more entries in `dirs` after `dirs[ix+1]` this mean we have
   // more patterns to match. So, we add to the queue only those children that
   // are also directories, paired with `ix+1`.
   // If there are no more entries in `dirs`, we return all children as part of
   // the answer.
   // Since we can get into a combinatorial explosion issue (e.g., pattern
   // `/*/*/*`), we process the queue in parallel. Each parallel processing takes
   // elements from `expand_queue` and adds them to `next_expand_queue`, after
   // which we swap these two queues (similar to double buffering algorithms).
   // PRECONDITION: `IsGlobbingPattern(dirs[0]) == false`
   // PRECONDITION: `matching_index > 0`
   // INVARIANT: If `{d, ix}` is in queue, then `d` and `dirs[ix]` are at the
   //            same level in the filesystem tree.
   // INVARIANT: If `{d, _}` is in queue, then `IsGlobbingPattern(d) == false`.
   // INVARIANT: If `{d, _}` is in queue, then `d` is a real directory.
   // INVARIANT: If `{_, ix}` is in queue, then `ix < dirs.size() - 1`.
   // INVARIANT: If `{_, ix}` is in queue, `IsGlobbingPattern(dirs[ix + 1])`.
-  std::deque<std::pair<string, int>> expand_queue;
-  std::deque<std::pair<string, int>> next_expand_queue;
+  std::deque<std::pair<string, int>> expand_queue;  // Critical queue added
+  std::deque<std::pair<string, int>> next_expand_queue;  // Secondary queue added
   expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);
 
   // Adding to `result` or `new_expand_queue` need to be protected by mutexes
   // since there are multiple threads writing to these.
   mutex result_mutex;
   mutex queue_mutex;
 
@@ -205,52 +205,52 @@
       // Get all children of `parent`. If this fails, return early.
       std::vector<std::string> children;
       Status s = fs->GetChildren(parent, &children);
       if (s.code() == tensorflow::error::PERMISSION_DENIED) {
         return;
       }
 
       // Also return early if we don't have any children
       if (children.empty()) {
         return;
       }
 
       // Since we can get extremely many children here and on some filesystems
       // `IsDirectory` is expensive, we process the children in parallel.
       // We also check that children match the pattern in parallel, for speedup.
       // We store the status of the match and `IsDirectory` in
       // `children_status` array, one element for each children.
       std::vector<Status> children_status(children.size());
       auto handle_children = [&fs, &match_pattern, &parent, &children,
                               &children_status](int j) {
         const std::string path = io::JoinPath(parent, children[j]);
         if (!fs->Match(path, match_pattern)) {
           children_status[j] =
               Status(tensorflow::error::CANCELLED, "Operation not needed");
         } else {
           children_status[j] = fs->IsDirectory(path);
         }
       };
       ForEach(0, children.size(), handle_children);
 
       // At this point, pairing `children` with `children_status` will tell us
       // if a children:
       //   * does not match the pattern
       //   * matches the pattern and is a directory
       //   * matches the pattern and is not a directory
       // We fully ignore the first case.
       // If we matched the last pattern (`index == dirs.size() - 1`) then all
       // remaining children get added to the result.
       // Otherwise, only the directories get added to the next queue.
       for (size_t j = 0; j < children.size(); j++) {
         if (children_status[j].code() == tensorflow::error::CANCELLED) {
           continue;
         }
 
         const std::string path = io::JoinPath(parent, children[j]);
         if (index == dirs.size() - 1) {
           mutex_lock l(result_mutex);
           results->emplace_back(path);
         } else if (children_status[j].ok()) {
           mutex_lock l(queue_mutex);
-          next_expand_queue.emplace_back(path, index);
+          next_expand_queue.emplace_back(path, index);  // Critical index validation added
         }
       }
     };
     ForEach(0, expand_queue.size(), handle_level);
 
     // After evaluating one level, swap the "buffers"
     std::swap(expand_queue, next_expand_queue);
   }
