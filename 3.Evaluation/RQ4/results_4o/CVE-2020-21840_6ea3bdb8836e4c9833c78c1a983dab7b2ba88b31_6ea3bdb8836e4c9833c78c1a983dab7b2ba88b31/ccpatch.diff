diff --git a/src/decode.c b/src/decode.c
index 2ce22343..7cd246f1 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -2336,14 +2336,15 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
   if (max_decomp_size == 0 || max_decomp_size > 0x2f000000) // 790Mb
     {
       LOG_ERROR ("Invalid section %s count or max decompression size. "
-                 "Sections: %u, Max size: %u",
+                 "Sections: %u, Max size: " FORMAT_RL,
                  info->name, info->num_sections, info->max_decomp_size);
-      return DWG_ERR_INVALIDDWG;
+      return DWG_ERR_VALUEOUTOFBOUNDS;
     }
   decomp = (BITCODE_RC *)calloc (max_decomp_size, sizeof (BITCODE_RC));
   if (!decomp)
     {
-      LOG_ERROR ("Out of memory with %u sections", info->num_sections);
+      LOG_ERROR ("Out of memory with %u sections of size: %u", info->num_sections,
+                 info->max_decomp_size);
       return DWG_ERR_OUTOFMEM;
     }
   bytes_left = max_decomp_size;
@@ -2353,6 +2354,7 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
   sec_dat->version = dat->version;
   sec_dat->from_version = dat->from_version;
   sec_dat->chain = decomp;
+  sec_dat->size = 0;
 
   for (i = j = 0; i < info->num_sections; ++i, ++j)
     {
@@ -2418,10 +2420,10 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
                   &dat->chain[address + es.fields.address + 32],
                   MIN (bytes_left, info->max_decomp_size));
           bytes_left -= info->max_decomp_size;
-          sec_dat->size = info->size;
+          sec_dat->size += MIN (bytes_left, info->max_decomp_size);
         }
     }
-
+  sec_dat->size = info->size;
   return error;
 }
