diff --git a/src/decode.c b/src/decode.c
index b79cd0d5..4061554e 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -2437,23 +2437,23 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
         }
       else
         {
-          BITCODE_RL size;
-          if (info->compressed == 2
-              || bytes_left < 0
+          const unsigned long offset = address + es.fields.address + 32;
+          // the remaining uncompressed size to read from
+          const BITCODE_RL size = MIN (info->size, info->max_decomp_size);
+          if (info->compressed == 2 || bytes_left < 0
               || (unsigned long)(es.fields.address + 32 + info->size
-                                  > max_decomp_size)
-              )
+                                 > max_decomp_size)
+              || (j * info->max_decomp_size) + size > max_decomp_size
+              || offset + size > dat->size)
             {
-              LOG_ERROR ("Some section size out of bounds")
+              LOG_ERROR ("Some section size or address out of bounds")
               sec_dat->chain = NULL;
               free (decomp);
               return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
                                                : DWG_ERR_VALUEOUTOFBOUNDS;
             }
-          // the remaining uncompressed size to read from
-          size = MIN (info->size, info->max_decomp_size);
-          memcpy (&decomp[j * info->max_decomp_size],
-                  &dat->chain[address + es.fields.address + 32], size);
+          assert (j < info->num_sections);
+          memcpy (&decomp[j * info->max_decomp_size], &dat->chain[offset], size);
           bytes_left -= size;
           sec_dat->size += size;
         }
