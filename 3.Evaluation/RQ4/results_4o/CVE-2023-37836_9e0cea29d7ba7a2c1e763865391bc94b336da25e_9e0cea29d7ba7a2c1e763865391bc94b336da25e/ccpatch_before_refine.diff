

diff --git a/cmd/bitmaphook.cpp b/cmd/bitmaphook.cpp
index cee7229..9f41dbe 100644
--- a/cmd/bitmaphook.cpp
+++ b/cmd/bitmaphook.cpp
@@ -160,8 +160,10 @@ JPG_LONG BitmapHook(struct JPG_Hook *hook, struct JPG_TagItem *tags)
           if (bmm->bmm_pLDRSource && bmm->bmm_pLDRMemPtr) {
             // A designated LDR source is available. Read from here rather than using
             // our primitive tone mapper.
-            fread(bmm->bmm_pLDRMemPtr,sizeof(UBYTE),width * height * bmm->bmm_usDepth,
-                  bmm->bmm_pLDRSource);
+            ssize_t cnt = fread(bmm->bmm_pLDRMemPtr,sizeof(UBYTE),width * height * bmm->bmm_usDepth,
+                                bmm->bmm_pLDRSource);
+            if (cnt != width * height * bmm->bmm_usDepth)
+              return JPGERR_UNEXPECTED_EOF;
           }
           //
           if (bmm->bmm_pSource) {
@@ -203,8 +205,10 @@ JPG_LONG BitmapHook(struct JPG_Hook *hook, struct JPG_TagItem *tags)
                 } while(--count);
               }
             } else {
-              fread(bmm->bmm_pMemPtr,bmm->bmm_ucPixelType & CTYP_SIZE_MASK,
-                    width * height * bmm->bmm_usDepth,bmm->bmm_pSource);
+              ssize_t cnt = fread(bmm->bmm_pMemPtr,bmm->bmm_ucPixelType & CTYP_SIZE_MASK,
+                                  width * height * bmm->bmm_usDepth,bmm->bmm_pSource);
+              if (cnt != width * height * bmm->bmm_usDepth)
+                return JPGERR_UNEXPECTED_EOF;
 #ifdef JPG_LIL_ENDIAN
               // On those bloddy little endian machines, an endian swap is necessary
               // as PNM is big-endian.
diff --git a/interface/bitmaphook.cpp b/interface/bitmaphook.cpp
index c32ebf8..b128164 100644
--- a/interface/bitmaphook.cpp
+++ b/interface/bitmaphook.cpp
@@ -192,8 +192,11 @@ void BitMapHook::Request(struct JPG_Hook *hook,struct JPG_TagItem *tags,UBYTE pi
   tags[22].ti_Data.ti_lData = 0;
   //
   // Now call the hook if it exists
-  if (hook)
-    hook->CallLong(tags);
+  if (hook) {
+    LONG result = hook->CallLong(tags);
+    if (result < 0)
+      comp->EnvironOf()->Throw(result,"BitmapHook::Request",__LINE__,__FILE__,"BitMapHook signalled an error");
+  }
 
   // and now, finally, scan what we got back
   ibm->ibm_pData           = tags[1].ti_Data.ti_pPtr;