

The vulnerability arises from improper handling of UTF-8 sequences in the `bit_utf8_to_TU` function. The original code lacked proper control flow with `else if` and braces, leading to multiple increments/decrements and buffer overflows. The patch corrects this by chaining conditions and scoping blocks.

```diff
diff --git a/src/bits.c b/src/bits.c
index fcd8bba0..b5f4aa13 100644
--- a/src/bits.c
+++ b/src/bits.c
@@ -2900,17 +2902,19 @@ bit_utf8_to_TU (char *restrict str, const unsigned cquoted)
             {
               LOG_WARN ("utf-8: BAD_CONTINUATION_BYTE %s", str);
             }
-          if (len >= 1 && c == 0xe0 && (unsigned char)str[1] < 0xa0)
+          else if (len >= 1 && c == 0xe0 && (unsigned char)str[1] < 0xa0)
             {
               LOG_WARN ("utf-8: NON_SHORTEST %s", str);
             }
-          if (len >= 2)
-            wstr[i++] = ((c & 0x0f) << 12) | ((str[1] & 0x3f) << 6)
-                        | (str[2] & 0x3f);
-          str++;
-          str++;
-          len--;
-          len--;
+          else if (len >= 2)
+            {
+              wstr[i++] = ((c & 0x0f) << 12) | ((str[1] & 0x3f) << 6)
+                | (str[2] & 0x3f);
+              str++;
+              str++;
+              len--;
+              len--;
+            }
         }
       /* everything above 0xf0 exceeds ucs-2, 4-6 byte seqs */
     }
``` 

This modification fixes the control flow in the 3-byte UTF-8 handling, preventing excessive `str` increments and `len` decrements that caused heap buffer overflow.