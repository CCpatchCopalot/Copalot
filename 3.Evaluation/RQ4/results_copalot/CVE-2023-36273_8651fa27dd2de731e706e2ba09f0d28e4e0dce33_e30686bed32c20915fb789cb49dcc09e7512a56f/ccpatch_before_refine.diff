diff --git a/src/bits.c b/src/bits.c
--- a/src/bits.c
+++ b/src/bits.c
@@ -1993,14 +1993,22 @@ bit_embed_TU (BITCODE_TU restrict wstr)
 void
 bit_write_TV (Bit_Chain *restrict dat, BITCODE_TV restrict chain)
 {
-  int i;
-  int length = (chain && *chain) ? strlen ((const char *)chain) : 0;
+  size_t i;
+  size_t length = (chain && *chain) ? strlen ((const char *)chain) : 0;
   if (dat->version <= R_2000 && length)
     length++;
+  if (length > UINT16_MAX)
+    {
+      // silently truncate overlong strings for now
+      loglevel = 1;
+      LOG_WARN ("Overlong string truncated (len=%lu)", (unsigned long)length);
+      length = UINT16_MAX;
+      chain[UINT16_MAX - 1] = '\0';
+    }
   if (dat->from_version < R_13b1)
-    bit_write_RS (dat, length);
+    bit_write_RS (dat, (BITCODE_BS)length);
   else
-    bit_write_BS (dat, length);
+    bit_write_BS (dat, (BITCODE_BS)length);
   for (i = 0; i < length; i++)
     bit_write_RC (dat, (unsigned char)chain[i]);
 }
@@ -2033,9 +2041,19 @@ bit_write_T (Bit_Chain *restrict dat, BITCODE_T restrict s)
               if (str)
                 {
                   length = strlen ((const char *)str);
-                  bit_write_BS (dat, length + 1);
-                  for (i = 0; i < length; i++)
-                    bit_write_RC (dat, (unsigned char)str[i]);
+                  if (length > UINT16_MAX)
+                    {
+                      loglevel = 1;
+                      LOG_WARN ("Overlong string truncated (len=%lu)",
+                                (unsigned long)length);
+                      length = UINT16_MAX - 1;
+                    }
+                  bit_write_BS (dat, (BITCODE_BS)(length + 1));
+                  if (length)
+                    {
+                      for (i = 0; i < length; i++)
+                        bit_write_RC (dat, (unsigned char)str[i]);
+                    }
                   bit_write_RC (dat, 0);
                   free (str);
                 }
@@ -2348,15 +2366,21 @@ void
 bit_write_TU (Bit_Chain *restrict dat, BITCODE_TU restrict chain)
 {
-  unsigned int i;
-  unsigned int length;
+  size_t i, length;
 
   if (chain)
     length = bit_wcs2len (chain) + 1;
   else
     length = 0;
+  if (length > UINT16_MAX)
+    {
+      loglevel = 1;
+      LOG_WARN ("Overlong string truncated (len=%lu)", (unsigned long)length);
+      length = UINT16_MAX;
+      chain[UINT16_MAX - 1] = '\0';
+    }
 
-  bit_write_BS (dat, length);
+  bit_write_BS (dat, (BITCODE_BS)length);
   for (i = 0; i < length; i++)
     bit_write_RS (dat, chain[i]); // probably without byte swapping
 }
@@ -2365,15 +2389,21 @@ void
 bit_write_TU16 (Bit_Chain *restrict dat, BITCODE_TU restrict chain)
 {
-  unsigned int i;
-  unsigned int length;
+  size_t i, length;
 
   if (chain)
     length = bit_wcs2len (chain) + 1;
   else
     length = 0;
+  if (length > UINT16_MAX)
+    {
+      loglevel = 1;
+      LOG_WARN ("Overlong string truncated (len=%lu)", (unsigned long)length);
+      length = UINT16_MAX;
+      chain[UINT16_MAX - 1] = '\0';
+    }
 
-  bit_write_RS (dat, length);
+  bit_write_RS (dat, (BITCODE_RS)length);
   for (i = 0; i < length; i++)
     bit_write_RS (dat, chain[i]);
 }
@@ -2380,7 +2410,14 @@ bit_write_T32 (Bit_Chain *restrict dat, BITCODE_T32 restrict chain)
         length = bit_wcs2len ((BITCODE_TU)chain) + 1;
       else
         length = 0;
-      bit_write_RL (dat, length * 2);
+      if (length > INT32_MAX)
+        {
+          loglevel = 1;
+          LOG_WARN ("Overlong string truncated (len=%lu)", (unsigned long)length);
+          length = INT32_MAX;
+          chain[INT32_MAX - 1] = '\0';
+        }
+      bit_write_RL (dat, (BITCODE_RL)(length * 2));
       for (i = 0; i < length; i++)
         bit_write_RS (dat, chain[i]);
     }
@@ -2390,7 +2427,14 @@ bit_write_TU32 (Bit_Chain *restrict dat, BITCODE_TU32 restrict chain)
         length = strlen (chain) + 1;
       else
         length = 0;
-      bit_write_RL (dat, length);
+      if (length > UINT32_MAX)
+        {
+          loglevel = 1;
+          LOG_WARN ("Overlong string truncated (len=%lu)", (unsigned long)length);
+          length = UINT32_MAX;
+          chain[UINT32_MAX - 1] = '\0';
+        }
+      bit_write_RL (dat, (BITCODE_RL)length);
       for (i = 0; i < length; i++)
         bit_write_RC (dat, chain[i]);
     }
@@ -2786,31 +2842,55 @@ BITCODE_TU
 bit_utf8_to_TU (char *restrict str, const unsigned cquoted)
 {
   BITCODE_TU wstr;
-  int i = 0;
-  int len = strlen (str);
+  size_t i = 0;
+  size_t len = strlen (str);
   unsigned char c;
 
-  wstr = (BITCODE_TU)malloc (2 * (len + 1));
+  if (len > 0xFFFE)
+    {
+      loglevel = 1;
+      LOG_WARN ("Overlong string truncated (len=%lu)",
+                (unsigned long)len);
+      len = UINT16_MAX - 1;
+    }
+  wstr = (BITCODE_TU)calloc (2, len + 1);
   if (!wstr)
     {
       loglevel = 1;
       LOG_ERROR ("Out of memory")
       return NULL;
     }
-  while (len >= 0 && (c = *str++))
+  while (len > 0 && (c = *str++))
     {
       len--;
       if (c < 128)
         {
-          wstr[i++] = c;
+          if (cquoted && c == '\\' && len > 1 &&
+              // skip \" to " and \\ to \.
+              (*str == '"' || *str == '\\' || *str == 'r'
+               || *str == 'n'))
+            {
+              c = *str++;
+              if (c == 'r')
+                wstr[i++] = '\r';
+              else if (c == 'n')
+                wstr[i++] = '\n';
+              // else skip \ and " from \\ and \"
+              else
+                wstr[i++] = c;
+            }
+          else
+            wstr[i++] = c;
         }
       else if ((c & 0xe0) == 0xc0)
         {
           /* ignore invalid utf8 for now */
           if (len >= 1)
-            wstr[i++] = ((c & 0x1f) << 6) | (str[1] & 0x3f);
-          len--;
-          str++;
+            {
+              wstr[i++] = ((c & 0x1f) << 6) | (str[1] & 0x3f);
+              len--;
+              str++;
+            }
         }
       else if ((c & 0xf0) == 0xe0)
         {
@@ -2822,21 +2902,22 @@ bit_utf8_to_TU (char *restrict str, const unsigned cquoted)
             {
               LOG_WARN ("utf-8: BAD_CONTINUATION_BYTE %s", str);
             }
-          if (len >= 1 && c == 0xe0 && (unsigned char)str[1] < 0xa0)
+          else if (len >= 1 && c == 0xe0 && (unsigned char)str[1] < 0xa0)
             {
               LOG_WARN ("utf-8: NON_SHORTEST %s", str);
             }
-          if (len >= 2)
-            wstr[i++] = ((c & 0x0f) << 12) | ((str[1] & 0x3f) << 6)
-                        | (str[2] & 0x3f);
-          str++;
-          str++;
-          len--;
-          len--;
+          else if (len >= 2)
+            {
+              wstr[i++] = ((c & 0x0f) << 12) | ((str[1] & 0x3f) << 6)
+                | (str[2] & 0x3f);
+              str++;
+              str++;
+              len--;
+              len--;
+            }
         }
       /* everything above 0xf0 exceeds ucs-2, 4-6 byte seqs */
     }
-  wstr[i] = '\0';
   return wstr;
 }