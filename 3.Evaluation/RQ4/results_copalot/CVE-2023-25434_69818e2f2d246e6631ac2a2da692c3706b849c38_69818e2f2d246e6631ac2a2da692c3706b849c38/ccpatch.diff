diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
old mode 100644
new mode 100755
index ebea7475..7089a1a5
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -577,7 +577,7 @@ static int rotateContigSamples24bits(uint16_t, uint16_t, uint16_t, uint32_t,
 static int rotateContigSamples32bits(uint16_t, uint16_t, uint16_t, uint32_t,
                                      uint32_t, uint32_t, uint8_t *, uint8_t *);
 static int rotateImage(uint16_t, struct image_data *, uint32_t *, uint32_t *,
-                       unsigned char **, size_t *);
+                        unsigned char **, size_t *, int);
 static int mirrorImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,
                        unsigned char *);
 static int invertImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,
@@ -7267,8 +7267,7 @@ static int correct_orientation(struct image_data *image,
             return (-1);
         }
 
-        if (rotateImage(rotation, image, &image->width, &image->length,
-                        work_buff_ptr, NULL))
+        if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr, NULL, TRUE))
         {
             TIFFError("correct_orientation", "Unable to rotate image");
             return (-1);
@@ -8635,7 +8634,7 @@ static int processCropSelections(struct image_data *image,
              * accordingly. */
             size_t rot_buf_size = 0;
             if (rotateImage(crop->rotation, image, &crop->combined_width,
-                            &crop->combined_length, &crop_buff, &rot_buf_size))
+                    &crop->combined_length, &crop_buff, &rot_buf_size, FALSE))
             {
                 TIFFError("processCropSelections",
                           "Failed to rotate composite regions by %" PRIu32
@@ -8905,7 +8904,7 @@ static int createCroppedImage(struct image_data *image, struct crop_mask *crop,
         CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
     {
         if (rotateImage(crop->rotation, image, &crop->combined_width,
-                        &crop->combined_length, crop_buff_ptr, NULL))
+                    &crop->combined_length, crop_buff_ptr, NULL, TRUE))
         {
             TIFFError("createCroppedImage",
                       "Failed to rotate image or cropped selection by %" PRIu16
@@ -9621,7 +9620,7 @@ static int rotateContigSamples32bits(uint16_t rotation, uint16_t spp,
 /* Rotate an image by a multiple of 90 degrees clockwise */
 static int rotateImage(uint16_t rotation, struct image_data *image,
                        uint32_t *img_width, uint32_t *img_length,
-                       unsigned char **ibuff_ptr, size_t *rot_buf_size)
+                       unsigned char **ibuff_ptr, size_t *rot_buf_size, int rot_image_params)
 {
     int shift_width;
     uint32_t bytes_per_pixel, bytes_per_sample;
@@ -9866,14 +9865,17 @@ static int rotateImage(uint16_t rotation, struct image_data *image,
             }
             _TIFFfree(ibuff);
             *(ibuff_ptr) = rbuff;
-
-            *img_width = length;
-            *img_length = width;
-            image->width = length;
-            image->length = width;
-            res_temp = image->xres;
-            image->xres = image->yres;
-            image->yres = res_temp;
+            
+            if (rot_image_params)
+            {
+                *img_width = length;
+                *img_length = width;
+                image->width = length;
+                image->length = width;
+                res_temp = image->xres;
+                image->xres = image->yres;
+                image->yres = res_temp;
+            }
             break;
 
         case 270:
@@ -9953,14 +9955,16 @@ static int rotateImage(uint16_t rotation, struct image_data *image,
             }
             _TIFFfree(ibuff);
             *(ibuff_ptr) = rbuff;
-
-            *img_width = length;
-            *img_length = width;
-            image->width = length;
-            image->length = width;
-            res_temp = image->xres;
-            image->xres = image->yres;
-            image->yres = res_temp;
+            if (rot_image_params)
+            {
+                *img_width = length;
+                *img_length = width;
+                image->width = length;
+                image->length = width;
+                res_temp = image->xres;
+                image->xres = image->yres;
+                image->yres = res_temp;
+            }
             break;
         default:
             break;
