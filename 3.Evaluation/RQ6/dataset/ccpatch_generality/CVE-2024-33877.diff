diff --git a/src/H5Dcontig.c b/src/H5Dcontig.c
--- a/src/H5Dcontig.c
+++ b/src/H5Dcontig.c
@@ -356,6 +356,65 @@
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__contig_delete */
 
+/*-------------------------------------------------------------------------
+ * Function:	H5D__contig_check
+ *
+ * Purpose:	Sanity check the contiguous info for a dataset.
+ *
+ * Return:	Non-negative on success/Negative on failure
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5D__contig_check(const H5F_t *f, const H5O_layout_t *layout, const H5S_extent_t *extent, const H5T_t *dt)
+{
+    hsize_t nelmts;              /* Number of elements in dataspace */
+    size_t  dt_size;             /* Size of datatype */
+    hsize_t data_size;           /* Raw data size */
+    herr_t  ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* Sanity check */
+    assert(f);
+    assert(layout);
+    assert(extent);
+    assert(dt);
+
+    /* Retrieve the number of elements in the dataspace */
+    nelmts = H5S_extent_nelem(extent);
+
+    /* Get the datatype's size */
+    if (0 == (dt_size = H5T_GET_SIZE(dt)))
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve size of datatype");
+
+    /* Compute the size of the dataset's contiguous storage */
+    data_size = nelmts * dt_size;
+
+    /* Check for overflow during multiplication */
+    if (nelmts != (data_size / dt_size))
+        HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "size of dataset's storage overflowed");
+
+    /* Check for invalid (corrupted in the file, probably) dimensions */
+    if (H5_addr_defined(layout->storage.u.contig.addr)) {
+        haddr_t rel_eoa; /* Relative end of file address	*/
+
+        if (HADDR_UNDEF == (rel_eoa = H5F_get_eoa(f, H5FD_MEM_DRAW)))
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to determine file size");
+
+        /* Check for invalid dataset size (from bad dimensions) putting the
+         * dataset elements off the end of the file
+         */
+        if (H5_addr_le((layout->storage.u.contig.addr + data_size), layout->storage.u.contig.addr))
+            HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "invalid dataset size, likely file corruption");
+        if (H5_addr_gt((layout->storage.u.contig.addr + data_size), rel_eoa))
+            HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "invalid dataset size, likely file corruption");
+    }
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5D__contig_check() */
+
 /*-------------------------------------------------------------------------
  * Function:	H5D__contig_construct
diff --git a/src/H5Defl.c b/src/H5Defl.c
--- a/src/H5Defl.c
+++ b/src/H5Defl.c
@@ -55,6 +55,7 @@
 
 /* Layout operation callbacks */
 static herr_t  H5D__efl_construct(H5F_t *f, H5D_t *dset);
+static herr_t  H5D__efl_init(H5F_t *f, const H5D_t *dset, hid_t dapl_id);
 static herr_t  H5D__efl_io_init(H5D_io_info_t *io_info, H5D_dset_io_info_t *dinfo);
 static ssize_t H5D__efl_readvv(const H5D_io_info_t *io_info, const H5D_dset_io_info_t *dset_info,
                                size_t dset_max_nseq, size_t *dset_curr_seq, size_t dset_len_arr[],
@@ -77,7 +78,7 @@
 /* External File List (EFL) storage layout I/O ops */
 const H5D_layout_ops_t H5D_LOPS_EFL[1] = {{
     H5D__efl_construct,      /* construct */
-    NULL,                    /* init */
+    H5D__efl_init,           /* init */
     H5D__efl_is_space_alloc, /* is_space_alloc */
     NULL,                    /* is_data_cached */
     H5D__efl_io_init,        /* io_init */
@@ -137,8 +138,9 @@
         HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unable to determine datatype size");
 
     /* Check for storage overflows */
-    max_points  = H5S_get_npoints_max(dset->shared->space);
-    max_storage = H5O_efl_total_size(&dset->shared->dcpl_cache.efl);
+    max_points = H5S_get_npoints_max(dset->shared->space);
+    if (H5O_efl_total_size(&dset->shared->dcpl_cache.efl, &max_storage) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve size of external file");
     if (H5S_UNLIMITED == max_points) {
         if (H5O_EFL_UNLIMITED != max_storage)
             HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unlimited dataspace but finite storage");
@@ -149,8 +151,8 @@
         HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "dataspace size exceeds external storage size");
 
     /* Compute the total size of dataset */
-    stmp_size = H5S_GET_EXTENT_NPOINTS(dset->shared->space);
-    assert(stmp_size >= 0);
+    if ((stmp_size = H5S_GET_EXTENT_NPOINTS(dset->shared->space)) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve number of elements in dataspace");
     tmp_size = (hsize_t)stmp_size * dt_size;
     H5_CHECKED_ASSIGN(dset->shared->layout.storage.u.contig.size, hsize_t, tmp_size, hssize_t);
 
@@ -161,6 +163,57 @@
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__efl_construct() */
 
+/*-------------------------------------------------------------------------
+ * Function:	H5D__efl_init
+ *
+ * Purpose:	Initialize the info for a EFL dataset.  This is
+ *		called when the dataset is initialized.
+ *
+ * Return:	Non-negative on success/Negative on failure
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+H5D__efl_init(H5F_t H5_ATTR_UNUSED *f, const H5D_t *dset, hid_t H5_ATTR_UNUSED dapl_id)
+{
+    size_t   dt_size;             /* Size of datatype */
+    hssize_t snelmts;             /* Temporary holder for number of elements in dataspace */
+    hsize_t  nelmts;              /* Number of elements in dataspace */
+    hsize_t  data_size;           /* Raw data size */
+    hsize_t  max_storage;         /* Maximum storage size */
+    herr_t   ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* Sanity check */
+    assert(dset);
+
+    /* Retrieve the size of the dataset's datatype */
+    if (0 == (dt_size = H5T_get_size(dset->shared->type)))
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unable to determine datatype size");
+
+    /* Retrieve the number of elements in the dataspace */
+    if ((snelmts = H5S_GET_EXTENT_NPOINTS(dset->shared->space)) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve number of elements in dataspace");
+    nelmts = (hsize_t)snelmts;
+
+    /* Compute the size of the dataset's contiguous storage */
+    data_size = nelmts * dt_size;
+
+    /* Check for overflow during multiplication */
+    if (nelmts != (data_size / dt_size))
+        HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "size of dataset's storage overflowed");
+
+    /* Check for storage overflows */
+    if (H5O_efl_total_size(&dset->shared->dcpl_cache.efl, &max_storage) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve size of external file");
+    if (H5O_EFL_UNLIMITED != max_storage && data_size > max_storage)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "dataspace size exceeds external storage size");
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5D__efl_init() */
+
 /*-------------------------------------------------------------------------
  * Function:	H5D__efl_is_space_alloc
diff --git a/src/H5Znbit.c b/src/H5Znbit.c
--- a/src/H5Znbit.c
+++ b/src/H5Znbit.c
@@ -947,8 +947,10 @@
             HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, 0, "memory allocation failed for nbit decompression");
 
         /* decompress the buffer */
-        if (H5Z__nbit_decompress(outbuf, d_nelmts, (unsigned char *)*buf, cd_values) < 0)
+        if (H5Z__nbit_decompress(outbuf, d_nelmts, (unsigned char *)*buf, cd_values) < 0) {
+            H5MM_xfree(outbuf);
             HGOTO_ERROR(H5E_PLINE, H5E_CANTFILTER, 0, "can't decompress buffer");
+        }
     } /* end if */
     /* output; compress */
     else {
@@ -1180,7 +1182,7 @@
 static herr_t
 H5Z__nbit_decompress_one_compound(unsigned char *data, size_t data_offset, unsigned char *buffer, size_t *j,
                                   size_t *buf_len, const unsigned parms[], unsigned *parms_index)
 {
-    unsigned     i, nmembers, member_offset, member_class, member_size, used_size = 0, size;
+    unsigned     i, nmembers, member_offset, member_class, member_size, used_size = 0, prev_used_size, size;
     parms_atomic p;
     herr_t       ret_value = SUCCEED; /* Return value */
 
@@ -1194,10 +1196,15 @@
         member_class  = parms[(*parms_index)++];
 
         /* Check for overflow */
-        member_size = parms[*parms_index];
+        member_size    = parms[*parms_index];
+        prev_used_size = used_size;
         used_size += member_size;
         if (used_size > size)
-            HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "compound member offset overflowed compound size");
+            HGOTO_ERROR(H5E_PLINE, H5E_BADVALUE, FAIL, "compound member size overflowed compound size");
+        if (used_size <= prev_used_size)
+            HGOTO_ERROR(H5E_PLINE, H5E_BADVALUE, FAIL, "compound member size overflowed compound size");
+        if ((member_offset + member_size) > size)
+            HGOTO_ERROR(H5E_PLINE, H5E_BADRANGE, FAIL, "compound member offset overflowed compound size");
         switch (member_class) {
             case H5Z_NBIT_ATOMIC:
                 p.size = member_size;
