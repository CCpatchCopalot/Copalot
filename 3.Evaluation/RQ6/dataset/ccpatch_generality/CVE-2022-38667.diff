diff --git a/include/crow/http_connection.h b/include/crow/http_connection.h
--- a/include/crow/http_connection.h
+++ b/include/crow/http_connection.h
@@ -84,6 +84,7 @@
                 if (!ec)
                 {
                     start_deadline();
+                    parser_.clear();
 
                     do_read();
                 }
@@ -137,7 +138,7 @@
                     is_invalid_request = true;
                     res = response(400);
                 }
-                if (req_.upgrade)
+                else if (req_.upgrade)
                 {
                     // h2 or h2c headers
                     if (req_.get_header_value("upgrade").substr(0, 2) == "h2")
@@ -409,6 +410,7 @@
             res.end();
             res.clear();
             buffers_.clear();
+            parser_.clear();
         }
 
         void do_write_general()
@@ -467,6 +469,7 @@
                 res.end();
                 res.clear();
                 buffers_.clear();
+                parser_.clear();
             }
         }
 
@@ -528,6 +531,7 @@
                   is_writing = false;
                   res.clear();
                   res_body_copy_.clear();
+                  parser_.clear();
                   if (!ec)
                   {
diff --git a/include/crow/http_parser_merged.h b/include/crow/http_parser_merged.h
--- a/include/crow/http_parser_merged.h
+++ b/include/crow/http_parser_merged.h
@@ -1576,7 +1576,6 @@
 
         if (parser->flags & F_TRAILING) {
           /* End of a chunked request */
-          parser->state = CROW_NEW_MESSAGE();
           CROW_CALLBACK_NOTIFY(message_complete);
           break;
         }
@@ -1652,14 +1651,12 @@
 
         /* Exit, the rest of the connect is in a different protocol. */
         if (parser->upgrade) {
-          parser->state = CROW_NEW_MESSAGE();
           CROW_CALLBACK_NOTIFY(message_complete);
           parser->nread = nread;
           return (p - data) + 1;
         }
 
         if (parser->flags & F_SKIPBODY) {
-          parser->state = CROW_NEW_MESSAGE();
           CROW_CALLBACK_NOTIFY(message_complete);
         } else if (parser->flags & F_CHUNKED) {
           /* chunked encoding - ignore Content-Length header,
@@ -1699,7 +1696,6 @@
             if (parser->content_length == 0)
             {
                 /* Content-Length header given but zero: Content-Length: 0\\r\\n */
-                parser->state = CROW_NEW_MESSAGE();
                 CROW_CALLBACK_NOTIFY(message_complete);
             }
             else if (parser->content_length != CROW_ULLONG_MAX)
@@ -1710,7 +1706,6 @@
             else
             {
                 /* Assume content-length 0 - read the next */
-                parser->state = CROW_NEW_MESSAGE();
                 CROW_CALLBACK_NOTIFY(message_complete);
             }
         }
@@ -1762,7 +1757,6 @@
         break;
 
       case s_message_done:
-        parser->state = CROW_NEW_MESSAGE();
         CROW_CALLBACK_NOTIFY(message_complete);
         break;
 
@@ -2007,9 +2001,7 @@
 #undef CROW_TOKEN
 #undef CROW_IS_URL_CHAR
 //#undef CROW_IS_HOST_CHAR
-#undef CROW_start_state
 #undef CROW_STRICT_CHECK
-#undef CROW_NEW_MESSAGE
 
 }
diff --git a/include/crow/parser.h b/include/crow/parser.h
--- a/include/crow/parser.h
+++ b/include/crow/parser.h
@@ -4,8 +4,8 @@
 #include <unordered_map>
 #include <algorithm>
 
-#include "crow/http_parser_merged.h"
 #include "crow/http_request.h"
+#include "crow/http_parser_merged.h"
 
 namespace crow
 {
@@ -19,7 +19,6 @@
         static int on_message_begin(http_parser* self_)
         {
             HTTPParser* self = static_cast<HTTPParser*>(self_);
-            self->clear();
             return 0;
         }
         static int on_method(http_parser* self_)
@@ -97,6 +96,7 @@
         {
             HTTPParser* self = static_cast<HTTPParser*>(self_);
 
+            self->message_complete = true;
             self->process_message();
             return 0;
         }
@@ -110,6 +110,9 @@
         /// Parse a buffer into the different sections of an HTTP request.
         bool feed(const char* buffer, int length)
         {
+            if (message_complete)
+                return true;
+
             const static http_parser_settings settings_{
               on_message_begin,
               on_method,
@@ -141,6 +144,8 @@
             header_value.clear();
             header_building_state = 0;
             qs_point = 0;
+            message_complete = false;
+            state = CROW_NEW_MESSAGE();
         }
 
         inline void process_url()
@@ -184,9 +189,13 @@
 
     private:
         int header_building_state = 0;
+        bool message_complete = false;
         std::string header_field;
         std::string header_value;
 
         Handler* handler_; ///< This is currently an HTTP connection object (\ref crow.Connection).
     };
 } // namespace crow
+
+#undef CROW_NEW_MESSAGE
+#undef CROW_start_state
