diff --git a/include/atalk/adouble.h b/include/atalk/adouble.h
index XXXXXXX..XXXXXXX 100644
--- a/include/atalk/adouble.h
+++ b/include/atalk/adouble.h
@@ -224,6 +224,7 @@ struct adouble {
     char                *ad_name;          /* mac name (maccharset or UTF8-MAC)       */
     struct adouble_fops *ad_ops;
     uint16_t            ad_open_forks;     /* open forks (by others)                  */
+    size_t              valid_data_len;    /* Bytes read into ad_data                 */
     char                ad_data[AD_DATASZ_MAX];
 };
 
@@ -371,7 +372,6 @@ struct adouble {
 #define ad_getentrylen(ad,eid)     ((ad)->ad_eid[(eid)].ade_len)
 #define ad_setentrylen(ad,eid,len) ((ad)->ad_eid[(eid)].ade_len = (len))
 #define ad_setentryoff(ad,eid,off) ((ad)->ad_eid[(eid)].ade_off = (off))
-#define ad_entry(ad,eid)           ((caddr_t)(ad)->ad_data + (ad)->ad_eid[(eid)].ade_off)
 
 #define ad_get_RF_flags(ad) ((ad)->ad_rfp->adf_flags)
 #define ad_get_MD_flags(ad) ((ad)->ad_mdp->adf_flags)
@@ -399,6 +399,7 @@ extern void ad_unlock(struct adouble *, int fork, int unlckbrl);
 extern int ad_tmplock(struct adouble *, uint32_t eid, int type, off_t off, off_t len, int fork);
 
 /* ad_open.c */
+extern void *ad_entry(const struct adouble *ad, int eid);
 extern off_t ad_getentryoff(const struct adouble *ad, int eid);
 extern const char *adflags2logstr(int adflags);
diff --git a/libatalk/adouble/ad_open.c b/libatalk/adouble/ad_open.c
index XXXXXXX..XXXXXXX 100644
--- a/libatalk/adouble/ad_open.c
+++ b/libatalk/adouble/ad_open.c
@@ -428,6 +428,7 @@ static int parse_entries(struct adouble *ad, uint16_t nentries, size_t valid_dat
         ad->ad_eid[eid].ade_len = len;
     }
 
+    ad->valid_data_len = valid_data_len;
     return 0;
 }
 
@@ -1532,6 +1533,50 @@ static int ad_open_rf(const char *path, int adflags, int mode, struct adouble *a
  * API functions
  ********************************************************************************* */
 
+static bool ad_entry_check_size(uint32_t eid, size_t bufsize, uint32_t off, uint32_t len)
+{
+    if (eid >= ADEID_MAX) {
+        return false;
+    }
+    
+    if (off + len > bufsize) {
+        return false;
+    }
+    
+    return true;
+}
+
+void *ad_entry(const struct adouble *ad, int eid)
+{
+    size_t bufsize = ad->valid_data_len;
+    off_t off = ad_getentryoff(ad, eid);
+    size_t len = ad_getentrylen(ad, eid);
+    bool valid;
+
+    valid = ad_entry_check_size(eid, bufsize, off, len);
+    if (!valid) {
+        return NULL;
+    }
+
+    if (off == 0 || len == 0) {
+        return NULL;
+    }
+
+    return ((struct adouble *)ad)->ad_data + off;
+}
+
 off_t ad_getentryoff(const struct adouble *ad, int eid)
 {
     if (ad->ad_vers == AD_VERSION2)