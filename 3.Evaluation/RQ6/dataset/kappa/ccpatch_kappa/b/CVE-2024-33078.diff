diff --git a/src/codec/tags/VideoSequence.cpp b/src/codec/tags/VideoSequence.cpp
--- a/src/codec/tags/VideoSequence.cpp
+++ b/src/codec/tags/VideoSequence.cpp
@@ -112,7 +112,7 @@
   auto length = stream->readEncodedUint32();
   auto bytes = stream->readBytes(length);
   // must check whether the bytes is valid. otherwise memcpy will crash.
-  if (length == 0 || stream->context->hasException()) {
+  if (length == 0 || length > bytes.length() || stream->context->hasException()) {
     return nullptr;
   }
diff --git a/src/codec/utils/DecodeStream.cpp b/src/codec/utils/DecodeStream.cpp
--- a/src/codec/utils/DecodeStream.cpp
+++ b/src/codec/utils/DecodeStream.cpp
@@ -22,7 +22,7 @@
 namespace pag {
 void DecodeStream::setPosition(uint32_t value) {
   if (!checkEndOfFile(value)) {
-    positionChanged(value - _position);
+    positionChanged(static_cast<size_t>(value) - _position);
   }
 }
 
@@ -288,17 +288,18 @@
   }
 }
 
-void DecodeStream::bitPositionChanged(off_t offset) {
+void DecodeStream::bitPositionChanged(size_t offset) {
   _bitPosition += offset;
   _position = BitsToBytes(_bitPosition);
 }
 
-void DecodeStream::positionChanged(off_t offset) {
+void DecodeStream::positionChanged(size_t offset) {
   _position += offset;
-  _bitPosition = static_cast<uint64_t>(_position) * 8;
+  _bitPosition = _position * 8;
 }
 
 bool DecodeStream::checkEndOfFile(uint32_t bytesToRead) {
+  // The _position must not use the uint32_t type, otherwise it will overflow.
   if (_position + bytesToRead > dataView.size()) {
     PAGThrowError(context, "End of file was encountered.");
diff --git a/src/codec/utils/DecodeStream.h b/src/codec/utils/DecodeStream.h
--- a/src/codec/utils/DecodeStream.h
+++ b/src/codec/utils/DecodeStream.h
@@ -60,7 +60,7 @@
    * the end of the stream.
    */
   uint32_t bytesAvailable() const {
-    return static_cast<uint32_t>(dataView.size()) - _position;
+    return static_cast<uint32_t>(dataView.size() - _position);
   }
 
   const uint8_t* data() const {
@@ -79,7 +79,7 @@
    * is the point at which the next call to a read method starts reading.
    */
   uint32_t position() const {
-    return _position;
+    return static_cast<uint32_t>(_position);
   }
 
   void setPosition(uint32_t value);
@@ -234,12 +234,12 @@
 
  private:
   tgfx::DataView dataView = {};
-  uint32_t _position = 0;
-  uint64_t _bitPosition = 0;
+  size_t _position = 0;
+  size_t _bitPosition = 0;
 
-  void bitPositionChanged(off_t offset);
+  void bitPositionChanged(size_t offset);
 
-  void positionChanged(off_t offset);
+  void positionChanged(size_t offset);
 
   bool checkEndOfFile(uint32_t bytesToRead);
diff --git a/src/codec/utils/NALUReader.cpp b/src/codec/utils/NALUReader.cpp
--- a/src/codec/utils/NALUReader.cpp
+++ b/src/codec/utils/NALUReader.cpp
@@ -24,7 +24,7 @@
   auto length = stream->readEncodedUint32();
   auto bytes = stream->readBytes(length);
   // must check whether the bytes is valid. otherwise memcpy will crash.
-  if (length == 0 || stream->context->hasException()) {
+  if (length == 0 || length > bytes.length() || stream->context->hasException()) {
     return nullptr;
   }
diff --git a/src/codec/utils/StreamContext.h b/src/codec/utils/StreamContext.h
--- a/src/codec/utils/StreamContext.h
+++ b/src/codec/utils/StreamContext.h
@@ -41,8 +41,8 @@
   std::vector<std::string> errorMessages;
 };
 
-inline uint32_t BitsToBytes(uint64_t capacity) {
-  return static_cast<uint32_t>(ceil(capacity * 0.125));
+inline size_t BitsToBytes(size_t capacity) {
+  return static_cast<size_t>(ceil(capacity * 0.125));
 }
 
 #ifdef DEBUG
