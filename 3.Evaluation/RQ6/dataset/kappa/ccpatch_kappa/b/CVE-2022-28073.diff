diff --git a/libr/core/anal_tp.c b/libr/core/anal_tp.c
--- a/libr/core/anal_tp.c
+++ b/libr/core/anal_tp.c
@@ -510,11 +510,6 @@
 		return;
 	}
 	char *pc = strdup (_pc);
-	RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);
-	if (!r) {
-		free (buf);
-		return;
-	}
 	r_cons_break_push (NULL, NULL);
 	r_list_sort (fcn->bbs, bb_cmpaddr); // TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address
 	r_list_foreach (fcn->bbs, it, bb) {
@@ -522,6 +517,11 @@
 		int i = 0;
+		RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);
+		if (!r) {
+			free (buf);
+			return;
+		}
 		r_reg_set_value (core->dbg->reg, r, addr);
 		while (1) {
 			if (r_cons_is_breaked ()) {
@@ -549,6 +549,11 @@
 			}
 			sdb_num_set (anal->esil->trace->db, sdb_fmt ("0x%""PFMT64x"".count", addr), loop_count + 1, 0);
 			if (r_anal_op_nonlinear (aop.type)) {   // skip the instr
+				RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);
+				if (!r) {
+					free (buf);
+					return;
+				}
 				r_reg_set_value (core->dbg->reg, r, addr + ret);
 			} else {
 				r_core_esil_step (core, UT64_MAX, NULL, NULL, false);
diff --git a/libr/reg/rvalue.c b/libr/reg/rvalue.c
--- a/libr/reg/rvalue.c
+++ b/libr/reg/rvalue.c
@@ -141,9 +141,10 @@
 }
 
 R_API bool r_reg_set_value(RReg *reg, RRegItem *item, ut64 value) {
+	r_return_val_if_fail (reg && item, false);
+
 	ut8 bytes[12];
 	ut8 *src = bytes;
-	r_return_val_if_fail (reg && item, false);
 
 	if (r_reg_is_readonly (reg, item)) {
 		return true;