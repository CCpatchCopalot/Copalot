diff --git a/libfreerdp/cache/bitmap.c b/libfreerdp/cache/bitmap.c
--- a/libfreerdp/cache/bitmap.c
+++ b/libfreerdp/cache/bitmap.c
@@ -214,7 +214,7 @@
 {
 	rdpBitmap* bitmap;
 
-	if (id > bitmapCache->maxCells)
+	if (id >= bitmapCache->maxCells)
 	{
 		WLog_ERR(TAG, "get invalid bitmap cell id: %" PRIu32 "", id);
 		return NULL;
@@ -271,7 +271,7 @@
 
 rdpBitmapCache* bitmap_cache_new(rdpSettings* settings)
 {
-	int i;
+	UINT32 i;
 	rdpBitmapCache* bitmapCache;
 	bitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));
 
@@ -288,7 +288,7 @@
 		goto fail;
 	bitmapCache->maxCells = settings->BitmapCacheV2NumCells;
 
-	for (i = 0; i < (int)bitmapCache->maxCells; i++)
+	for (i = 0; i < bitmapCache->maxCells; i++)
 	{
 		bitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;
 		/* allocate an extra entry for BITMAP_CACHE_WAITING_LIST_INDEX */
@@ -301,13 +301,7 @@
 
 	return bitmapCache;
 fail:
-
-	if (bitmapCache->cells)
-	{
-		for (i = 0; i < (int)bitmapCache->maxCells; i++)
-			free(bitmapCache->cells[i].entries);
-	}
-
+	bitmap_cache_free(bitmapCache);
- 	free(bitmapCache);
 	return NULL;
 }
@@ -318,9 +312,9 @@
 
 	if (bitmapCache)
 	{
-		for (i = 0; i < (int)bitmapCache->maxCells; i++)
+		for (i = 0; i < bitmapCache->maxCells; i++)
 		{
-			for (j = 0; j < (int)bitmapCache->cells[i].number + 1; j++)
+			for (j = 0; j < bitmapCache->cells[i].number + 1; j++)
 			{
 				bitmap = bitmapCache->cells[i].entries[j];
 				Bitmap_Free(bitmapCache->context, bitmap);