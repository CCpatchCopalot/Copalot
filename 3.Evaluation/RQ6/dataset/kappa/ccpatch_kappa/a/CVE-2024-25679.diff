diff --git a/picoquic/packet.c b/picoquic/packet.c
--- a/picoquic/packet.c
+++ b/picoquic/packet.c
@@ -485,11 +485,13 @@
                 /* Packet is not encrypted */
                 break;
             case picoquic_packet_initial:
-                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,
-                    (*pcnx)->crypto_context[0].hp_dec,
-                    (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);
-                length = ph->offset + ph->payload_length;
-                *consumed = length;
+                if((*pcnx)->crypto_context[0].aead_decrypt != NULL){
+                    decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,
+                        (*pcnx)->crypto_context[0].hp_dec,
+                        (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);
+                    length = ph->offset + ph->payload_length;
+                    *consumed = length;
+                }
                 break;
             case picoquic_packet_retry:
                 /* packet is not encrypted, no sequence number. */
@@ -1372,6 +1374,12 @@
                 else
                 {
                     ret = picoquic_incoming_client_cleartext(cnx, bytes, &ph, current_time);
+                    
+                    if (ret == 0 && cnx->crypto_context[2].aead_decrypt != NULL && cnx->crypto_context[2].aead_encrypt != NULL)
+                    {
+                        picoquic_implicit_handshake_ack(cnx, cnx->path[0], picoquic_packet_context_initial, current_time);
+                        picoquic_crypto_context_free(&cnx->crypto_context[0]);
+                    }
                 }
                 break;
             case picoquic_packet_0rtt_protected:
