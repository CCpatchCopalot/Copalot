diff --git a/src/atom_rtp.cpp b/src/atom_rtp.cpp
--- a/src/atom_rtp.cpp
+++ b/src/atom_rtp.cpp
@@ -125,10 +125,17 @@
 
     // read sdp string, length is implicit in size of atom
     uint64_t size = GetEnd() - m_File.GetPosition();
     char* data = (char*)MP4Malloc(size + 1);
     ASSERT(data != NULL);
-    m_File.ReadBytes((uint8_t*)data, size);
-    data[size] = '\0';
-    ((MP4StringProperty*)m_pProperties[1])->SetValue(data);
-    MP4Free(data);
+    try {
+        m_File.ReadBytes((uint8_t*)data, size);
+        data[size] = '\0';
+        ((MP4StringProperty*)m_pProperties[1])->SetValue(data);
+        MP4Free(data);
+    }
+    catch (Exception*) {
+        // free memory and rethrow
+        MP4Free(data);
+        throw;
+    }
 }
diff --git a/src/atom_sdp.cpp b/src/atom_sdp.cpp
--- a/src/atom_sdp.cpp
+++ b/src/atom_sdp.cpp
@@ -36,10 +36,17 @@
 
     // read sdp string, length is implicit in size of atom
     uint64_t size = GetEnd() - m_File.GetPosition();
     char* data = (char*)MP4Malloc(size + 1);
     ASSERT(data != NULL);
-    m_File.ReadBytes((uint8_t*)data, size);
-    data[size] = '\0';
-    ((MP4StringProperty*)m_pProperties[0])->SetValue(data);
-    MP4Free(data);
+    try {
+        m_File.ReadBytes((uint8_t*)data, size);
+        data[size] = '\0';
+        ((MP4StringProperty*)m_pProperties[0])->SetValue(data);
+        MP4Free(data);
+    }
+    catch (Exception*) {
+        // free memory and rethrow
+        MP4Free(data);
+        throw;
+    }
 }
diff --git a/src/mp4file_io.cpp b/src/mp4file_io.cpp
--- a/src/mp4file_io.cpp
+++ b/src/mp4file_io.cpp
@@ -327,17 +327,24 @@
     uint32_t length = 0;
     uint32_t alloced = 64;
     char* data = (char*)MP4Malloc(alloced);
-
-    do {
-        if (length == alloced) {
-            data = (char*)MP4Realloc(data, alloced * 2);
-            if (data == NULL) return NULL;
-            alloced *= 2;
-        }
-        ReadBytes((uint8_t*)&data[length], 1);
-        length++;
-    } while (data[length - 1] != 0);
-
-    data = (char*)MP4Realloc(data, length);
+    try {
+        do {
+            if (length == alloced) {
+                data = (char*)MP4Realloc(data, alloced * 2);
+                if (data == NULL)
+                    return NULL;
+                alloced *= 2;
+            }
+            ReadBytes((uint8_t*)&data[length], 1);
+            length++;
+        } while (data[length - 1] != 0);
+
+        data = (char*)MP4Realloc(data, length);
+    }
+    catch (Exception*) {
+        // free memory and rethrow
+        MP4Free(data);
+        throw;
+    }
     return data;
 }
 
@@ -387,15 +394,25 @@
     char* data = (char*)MP4Malloc(byteLength + 1);
     if (byteLength > 0) {
         ReadBytes((uint8_t*)data, byteLength);
     }
     data[byteLength] = '\0';
 
     // read padding
     if (fixedLength) {
         const uint8_t padsize = fixedLength - byteLength -1U;
         if( padsize ) {
-            uint8_t* padbuf = (uint8_t*)malloc( padsize );
-            ReadBytes( padbuf, padsize );
-            free( padbuf );
+            uint8_t* padbuf = (uint8_t*)MP4Malloc(padsize);
+            try {
+                ReadBytes(padbuf, padsize);
+                MP4Free(padbuf);
+            }
+            catch (Exception*) {
+                // free memory and rethrow
+                MP4Free(padbuf);
+                throw;
+            }
         }
     }
 
     return data;
 }
