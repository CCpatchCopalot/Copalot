diff --git a/src/H5Dint.c b/src/H5Dint.c
index 3b9d000f523..71ddda387c7 100644
--- a/src/H5Dint.c
+++ b/src/H5Dint.c
@@ -1673,11 +1673,12 @@ static herr_t
 H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
 {
     H5P_genplist_t *plist;                     /* Property list */
-    H5O_fill_t     *fill_prop;                 /* Pointer to dataset's fill value info */
+    H5O_fill_t     *fill_prop = NULL;          /* Pointer to dataset's fill value info */
     unsigned        alloc_time_state;          /* Allocation time state */
     htri_t          msg_exists;                /* Whether a particular type of message exists */
     bool            layout_init       = false; /* Flag to indicate that chunk information was initialized */
     bool            must_init_storage = false;
+    bool            fill_init         = false;   /* Flag to indicate that fill information was initialized */
     herr_t          ret_value         = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE_TAG(dataset->oloc.addr)
@@ -1722,34 +1723,6 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
     /* Indicate that the layout information was initialized */
     layout_init = true;
 
-    /*
-     * Now that we've read the dataset's datatype, dataspace and
-     * layout information, perform a quick check for compact datasets
-     * to ensure that the size of the internal buffer that was
-     * allocated for the dataset's raw data matches the size of
-     * the data. A corrupted file can cause a mismatch between the
-     * two, which might result in buffer overflows during future
-     * I/O to the dataset.
-     */
-    if (H5D_COMPACT == dataset->shared->layout.type) {
-        hssize_t dset_nelemts   = 0;
-        size_t   dset_type_size = H5T_GET_SIZE(dataset->shared->type);
-        size_t   dset_data_size = 0;
-
-        assert(H5D_COMPACT == dataset->shared->layout.storage.type);
-
-        if ((dset_nelemts = H5S_GET_EXTENT_NPOINTS(dataset->shared->space)) < 0)
-            HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL,
-                        "can't get number of elements in dataset's dataspace");
-
-        dset_data_size = (size_t)dset_nelemts * dset_type_size;
-
-        if (dataset->shared->layout.storage.u.compact.size != dset_data_size)
-            HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL,
-                        "bad value from dataset header - size of compact dataset's data buffer doesn't match "
-                        "size of dataset data");
-    }
-
     /* Set up flush append property */
     if (H5D__append_flush_setup(dataset, dapl_id))
         HGOTO_ERROR(H5E_DATASET, H5E_CANTSET, FAIL, "unable to set up flush append property");
@@ -1763,6 +1736,9 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
     if (msg_exists) {
         if (NULL == H5O_msg_read(&(dataset->oloc), H5O_FILL_NEW_ID, fill_prop))
             HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't retrieve message");
+
+        /* Indicate that the fill information was initialized */
+        fill_init = true;
     } /* end if */
     else {
         /* For backward compatibility, try to retrieve the old fill value message */
@@ -1771,6 +1747,9 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
         if (msg_exists) {
             if (NULL == H5O_msg_read(&(dataset->oloc), H5O_FILL_ID, fill_prop))
                 HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't retrieve message");
+
+            /* Indicate that the fill information was initialized */
+            fill_init = true;
         } /* end if */
         else {
             /* Set the space allocation time appropriately, based on the type of dataset storage */
@@ -1809,6 +1788,33 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
         (dataset->shared->layout.type == H5D_VIRTUAL && fill_prop->alloc_time == H5D_ALLOC_TIME_INCR))
         alloc_time_state = 1;
 
+    /* Check if there is a fill value, but no type yet */
+    if (fill_prop->buf != NULL && fill_prop->type == NULL) {
+        H5T_t *tmp_type; /* Temporary pointer to dataset's datatype */
+
+        /* Copy the dataset type into the fill value message */
+        if (NULL == (tmp_type = H5T_copy(dataset->shared->type, H5T_COPY_TRANSIENT)))
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTCOPY, FAIL, "unable to copy dataset datatype for fill value");
+
+        /* Check if conversion is necessary on fill buffer, and if fill-value
+         * buffer is too small to hold the result.
+         */
+        if (!H5T_noop_conv(dataset->shared->type, tmp_type)) {
+            size_t bkg_size = MAX(H5T_GET_SIZE(tmp_type), H5T_GET_SIZE(dataset->shared->type));
+
+            assert(fill_prop->size >= 0);
+            if ((size_t)fill_prop->size < bkg_size) {
+                if (H5T_close_real(tmp_type) < 0)
+                    HDONE_ERROR(H5E_DATASET, H5E_CANTFREE, FAIL, "Can't free temporary datatype");
+                HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL,
+                            "fill value size doesn't match dataset's datatype size");
+            }
+        }
+
+        if (H5T_close_real(tmp_type) < 0)
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTFREE, FAIL, "Can't free temporary datatype");
+    }
+
     /* Set revised fill value properties, if they are different from the defaults */
     if (H5P_fill_value_cmp(&H5D_def_dset.dcpl_cache.fill, fill_prop, sizeof(H5O_fill_t))) {
         if (H5P_set(plist, H5D_CRT_FILL_VALUE_NAME, fill_prop) < 0)
@@ -1845,6 +1851,8 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
         if (H5_addr_defined(dataset->oloc.addr) && H5O_close(&(dataset->oloc), NULL) < 0)
             HDONE_ERROR(H5E_DATASET, H5E_CLOSEERROR, FAIL, "unable to release object header");
         if (dataset->shared) {
+            if (fill_init)
+                H5O_msg_reset(H5O_FILL_ID, fill_prop);
             if (layout_init)
                 if (dataset->shared->layout.ops->dest && (dataset->shared->layout.ops->dest)(dataset) < 0)
                     HDONE_ERROR(H5E_DATASET, H5E_CANTRELEASE, FAIL, "unable to destroy layout info");
diff --git a/src/H5Gnode.c b/src/H5Gnode.c
index b4bd1214bf8..f211e74e041 100644
--- a/src/H5Gnode.c
+++ b/src/H5Gnode.c
@@ -344,6 +344,7 @@ H5G__node_cmp2(void *_lt_key, void *_udata, void *_rt_key)
     H5G_node_key_t  *lt_key = (H5G_node_key_t *)_lt_key;
     H5G_node_key_t  *rt_key = (H5G_node_key_t *)_rt_key;
     const char      *s1, *s2;
+    size_t           max_len;
     int              ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
@@ -359,8 +360,14 @@ H5G__node_cmp2(void *_lt_key, void *_udata, void *_rt_key)
     if ((s2 = (const char *)H5HL_offset_into(udata->heap, rt_key->offset)) == NULL)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get key name");
 
+    /* Compute maximum length of string to compare */
+    if (rt_key->offset > lt_key->offset)
+        max_len = udata->block_size - rt_key->offset;
+    else
+        max_len = udata->block_size - lt_key->offset;
+
     /* Set return value */
-    ret_value = strcmp(s1, s2);
+    ret_value = strncmp(s1, s2, max_len);
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
@@ -406,13 +413,13 @@ H5G__node_cmp3(void *_lt_key, void *_udata, void *_rt_key)
         if (udata->skip > 0)
             --udata->skip;
         else {
-            H5O_link_t  lnk;  /* Link for entry */
-            const char *name; /* Pointer to link name in heap */
-
-            /* Get the pointer to the name of the link in the heap */
-            if ((name = (const char *)H5HL_offset_into(udata->heap, ents[u].name_off)) == NULL)
-                HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get symbol table node name");
+            H5O_link_t lnk; /* Link for entry */
 
             /* Convert the entry to a link */
-            if (H5G__ent_to_link(&lnk, udata->heap, &ents[u], name) < 0)
+            if (H5G__ent_to_link(&ents[u], udata->heap, &lnk) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTCONVERT, FAIL,
                             "unable to convert symbol table entry to link");
 
             /* Make callback */
             if ((ret_value = (udata->op)(&lnk, udata->op_data)) != H5_ITER_CONT)
                 HERROR(H5E_SYM, H5E_CANTNEXT, "iteration operator failed");
         } /* end else */
     }     /* end for */
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G__node_iterate() */
diff --git a/src/H5Gobj.c b/src/H5Gobj.c
index b862947f195..1982f54984c 100644
--- a/src/H5Gobj.c
+++ b/src/H5Gobj.c
@@ -175,70 +175,6 @@ H5G__link_cmp_corder_dec(const void *lnk1, const void *lnk2)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G__link_cmp_corder_dec() */
 
-/*-------------------------------------------------------------------------
- * Function:	H5G__ent_to_link
- *
- * Purpose:     Convert a symbol table entry to a link
- *
- * Return:	Non-negative on success/Negative on failure
- *
- *-------------------------------------------------------------------------
- */
-herr_t
-H5G__ent_to_link(H5O_link_t *lnk, const H5HL_t *heap, const H5G_entry_t *ent, const char *name)
-{
-    bool   dup_soft  = false;   /* xstrdup the symbolic link name or not */
-    herr_t ret_value = SUCCEED; /* Return value */
-
-    FUNC_ENTER_PACKAGE
-
-    /* check arguments */
-    assert(lnk);
-    assert(heap);
-    assert(ent);
-    assert(name);
-
-    /* Set (default) common info for link */
-    lnk->cset         = H5F_DEFAULT_CSET;
-    lnk->corder       = 0;
-    lnk->corder_valid = false; /* Creation order not valid for this link */
-    if ((lnk->name = H5MM_xstrdup(name)) == NULL)
-        HGOTO_ERROR(H5E_LINK, H5E_CANTGET, FAIL, "unable to duplicate link name");
-
-    /* Object is a symbolic or hard link */
-    if (ent->type == H5G_CACHED_SLINK) {
-        const char *s; /* Pointer to link value */
-
-        if ((s = (const char *)H5HL_offset_into(heap, ent->cache.slink.lval_offset)) == NULL)
-            HGOTO_ERROR(H5E_LINK, H5E_CANTGET, FAIL, "unable to get symbolic link name");
-
-        /* Copy the link value */
-        if ((lnk->u.soft.name = H5MM_xstrdup(s)) == NULL)
-            HGOTO_ERROR(H5E_LINK, H5E_CANTGET, FAIL, "unable to duplicate symbolic link name");
-
-        dup_soft = true;
-
-        /* Set link type */
-        lnk->type = H5L_TYPE_SOFT;
-    } /* end if */
-    else {
-        /* Set address of object */
-        lnk->u.hard.addr = ent->header;
-
-        /* Set link type */
-        lnk->type = H5L_TYPE_HARD;
-    } /* end else */
-
-done:
-    if (ret_value < 0) {
-        if (lnk->name)
-            H5MM_xfree(lnk->name);
-        if (ent->type == H5G_CACHED_SLINK && dup_soft)
-            H5MM_xfree(lnk->u.soft.name);
-    }
-    FUNC_LEAVE_NOAPI(ret_value)
-} /* end H5G__ent_to_link() */
-
 /*-------------------------------------------------------------------------
  * Function:	H5G_link_to_info
  *
@@ -317,6 +253,140 @@ H5G_link_to_info(const H5O_loc_t *link_loc, const H5O_link_t *lnk, H5L_info2_t *
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G_link_to_info() */
 
+/*-------------------------------------------------------------------------
+ * Function:    H5G__link_to_ent
+ *
+ * Purpose:     Convert a link to a symbol table entry
+ *
+ * Return:	Success:	Non-negative
+ *		Failure:	Negative
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5G__link_to_ent(H5F_t *f, H5HL_t *heap, const H5O_link_t *lnk, H5O_type_t obj_type, const void *crt_info,
+                 H5G_entry_t *ent)
+{
+    size_t name_offset;         /* Offset of name in heap */
+    herr_t ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* check arguments */
+    assert(f);
+    assert(heap);
+    assert(lnk && lnk->name);
+
+    /* Reset the new entry */
+    H5G__ent_reset(ent);
+
+    /* Add the new name to the heap */
+    if (H5HL_insert(f, heap, strlen(lnk->name) + 1, lnk->name, &name_offset) < 0)
+        HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, FAIL, "unable to insert symbol name into heap");
+    ent->name_off = name_offset;
+
+    /* Build correct information for symbol table entry based on link type */
+    switch (lnk->type) {
+        case H5L_TYPE_HARD:
+            if (obj_type == H5O_TYPE_GROUP) {
+                const H5G_obj_create_t *gcrt_info = (const H5G_obj_create_t *)crt_info;
+
+                ent->type = gcrt_info->cache_type;
+                if (ent->type != H5G_NOTHING_CACHED)
+                    ent->cache = gcrt_info->cache;
+#ifndef NDEBUG
+                else {
+                    /* Make sure there is no stab message in the target object
+                     */
+                    H5O_loc_t targ_oloc;   /* Location of link target */
+                    htri_t    stab_exists; /* Whether the target symbol table exists */
+
+                    /* Build target object location */
+                    if (H5O_loc_reset(&targ_oloc) < 0)
+                        HGOTO_ERROR(H5E_SYM, H5E_CANTRESET, FAIL, "unable to initialize target location");
+                    targ_oloc.file = f;
+                    targ_oloc.addr = lnk->u.hard.addr;
+
+                    /* Check if a symbol table message exists */
+                    if ((stab_exists = H5O_msg_exists(&targ_oloc, H5O_STAB_ID)) < 0)
+                        HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, FAIL, "unable to check for STAB message");
+
+                    assert(!stab_exists);
+                } /* end else */
+#endif            /* NDEBUG */
+            }     /* end if */
+            else if (obj