diff --git a/source/extensions/filters/http/oauth2/filter.cc b/source/extensions/filters/http/oauth2/filter.cc
index 446e3394de77..9ef2f455b235 100644
--- a/source/extensions/filters/http/oauth2/filter.cc
+++ b/source/extensions/filters/http/oauth2/filter.cc
@@ -290,17 +290,7 @@ Http::FilterHeadersStatus OAuth2Filter::decodeHeaders(Http::RequestHeaderMap& he
     request_headers_ = &headers;
   }
 
-  // If a bearer token is supplied as a header or param, we ingest it here and kick off the
-  // user resolution immediately. Note this comes after HMAC validation, so technically this
-  // header is sanitized in a way, as the validation check forces the correct Bearer Cookie value.
-  access_token_ = extractAccessToken(headers);
-  if (!access_token_.empty()) {
-    found_bearer_token_ = true;
-    finishFlow();
-    return Http::FilterHeadersStatus::Continue;
-  }
-
-  // If no access token and this isn't the callback URI, redirect to acquire credentials.
+  // If this isn't the callback URI, redirect to acquire credentials.
   //
   // The following conditional could be replaced with a regex pattern-match,
   // if we're concerned about strict matching against the callback path.
@@ -439,18 +429,6 @@ void OAuth2Filter::onGetAccessTokenSuccess(const std::string& access_code,
 }
 
 void OAuth2Filter::finishFlow() {
-
-  // We have fully completed the entire OAuth flow, whether through Authorization header or from
-  // user redirection to the auth server.
-  if (found_bearer_token_) {
-    if (config_->forwardBearerToken()) {
-      setBearerToken(*request_headers_, access_token_);
-    }
-    config_->stats().oauth_success_.inc();
-    decoder_callbacks_->continueDecoding();
-    return;
-  }
-
   std::string token_payload;
   if (config_->forwardBearerToken()) {
     token_payload = absl::StrCat(host_, new_expires_, access_token_, id_token_, refresh_token_);
@@ -509,7 +487,6 @@ void OAuth2Filter::finishFlow() {
 
   decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_LOGGED_IN);
   config_->stats().oauth_success_.inc();
-  decoder_callbacks_->continueDecoding();
 }
 
diff --git a/source/extensions/filters/http/oauth2/filter.h b/source/extensions/filters/http/oauth2/filter.h
index 06838a5b65ff..c7d10dddeb82 100644
--- a/source/extensions/filters/http/oauth2/filter.h
+++ b/source/extensions/filters/http/oauth2/filter.h
@@ -243,7 +243,6 @@ class OAuth2Filter : public Http::PassThroughDecoderFilter, public FilterCallbac
   std::string new_expires_;
   absl::string_view host_;
   std::string state_;
-  bool found_bearer_token_{false};
   Http::RequestHeaderMap* request_headers_{nullptr};
 
diff --git a/test/extensions/filters/http/oauth2/filter_test.cc b/test/extensions/filters/http/oauth2/filter_test.cc
index 80445e0effdc..74586168404c 100644
--- a/test/extensions/filters/http/oauth2/filter_test.cc
+++ b/test/extensions/filters/http/oauth2/filter_test.cc
@@ -790,7 +790,6 @@ TEST_F(OAuth2Test, OAuthTestFullFlowPostWithParameters) {
 
   EXPECT_CALL(decoder_callbacks_,
               encodeHeaders_(HeaderMapEqualRef(&second_response_headers), true));
-  EXPECT_CALL(decoder_callbacks_, continueDecoding());
 
   filter_->finishFlow();
 }
@@ -817,8 +816,8 @@ TEST_F(OAuth2Test, OAuthBearerTokenFlowFromHeader) {
   EXPECT_CALL(*validator_, setParams(_, _));
   EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));
 
-  EXPECT_EQ(Http::FilterHeadersStatus::Continue,
-            filter_->decodeHeaders(request_headers_before, false));
+  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
+            filter_->decodeHeaders(request_headers, false));
 }
 
 TEST_F(OAuth2Test, OAuthBearerTokenFlowFromQueryParameters) {
@@ -834,8 +833,8 @@ TEST_F(OAuth2Test, OAuthBearerTokenFlowFromQueryParameters) {
   EXPECT_CALL(*validator_, setParams(_, _));
   EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));
 
-  EXPECT_EQ(Http::FilterHeadersStatus::Continue,
-            filter_->decodeHeaders(request_headers_before, false));
+  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
+            filter_->decodeHeaders(request_headers, false));
 }
 
 } // namespace Oauth2