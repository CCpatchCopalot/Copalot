diff --git a/src/H5Dcompact.c b/src/H5Dcompact.c
index 864d4963a6e..de84034f638 100644
--- a/src/H5Dcompact.c
+++ b/src/H5Dcompact.c
@@ -198,6 +198,63 @@ H5D__compact_construct(H5F_t *f, H5D_t *dset)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__compact_construct() */
 
+/*-------------------------------------------------------------------------
+ * Function:	H5D__compact_init
+ *
+ * Purpose:	Initialize the info for a compact dataset.  This is
+ *		called when the dataset is initialized.
+ *
+ * Return:	Non-negative on success/Negative on failure
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+H5D__compact_init(H5F_t H5_ATTR_UNUSED *f, const H5D_t *dset, hid_t H5_ATTR_UNUSED dapl_id)
+{
+    hssize_t snelmts;             /* Temporary holder for number of elements in dataspace */
+    hsize_t  nelmts;              /* Number of elements in dataspace */
+    size_t   dt_size;             /* Size of datatype */
+    hsize_t  data_size;           /* Dataset size, in bytes */
+    herr_t   ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* Sanity check */
+    assert(dset);
+    assert(H5D_COMPACT == dset->shared->layout.storage.type);
+
+    /*
+     * Now that we've read the dataset's datatype, dataspace and
+     * layout information, perform a quick check for compact datasets
+     * to ensure that the size of the internal buffer that was
+     * allocated for the dataset's raw data matches the size of
+     * the data. A corrupted file can cause a mismatch between the
+     * two, which might result in buffer overflows during future
+     * I/O to the dataset.
+     */
+    if (0 == (dt_size = H5T_GET_SIZE(dset->shared->type)))
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get datatype size");
+    if ((snelmts = H5S_GET_EXTENT_NPOINTS(dset->shared->space)) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get number of elements in dataset's dataspace");
+    nelmts = (hsize_t)snelmts;
+
+    /* Compute the size of the dataset's contiguous storage */
+    data_size = nelmts * dt_size;
+
+    /* Check for overflow during multiplication */
+    if (nelmts != (data_size / dt_size))
+        HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "size of dataset's storage overflowed");
+
+    /* Check for mismatch */
+    if (dset->shared->layout.storage.u.compact.size != data_size)
+        HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL,
+                    "bad value from dataset header - size of compact dataset's data buffer doesn't match "
+                    "size of dataset data");
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5D__compact_init() */
+
 /*-------------------------------------------------------------------------
  * Function:	H5D__compact_is_space_alloc
  *
diff --git a/src/H5Odtype.c b/src/H5Odtype.c
index 674d8d4ea1c..24671b02107 100644
--- a/src/H5Odtype.c
+++ b/src/H5Odtype.c
@@ -366,6 +366,7 @@ H5O__dtype_decode_helper(unsigned *ioflags /*in,out*/, const uint8_t **pp, H5T_t
                 hsize_t  dim[H5O_LAYOUT_NDIMS];  /* Dimensions of the array */
                 H5T_t   *array_dt;               /* Temporary pointer to the array datatype */
                 H5T_t   *temp_type;              /* Temporary pointer to the field's datatype */
+                unsigned memb_idx;               /* Local index counter */
 
                 /* Get the length of the field name */
                 if (!skip) {
@@ -388,6 +389,13 @@ H5O__dtype_decode_helper(unsigned *ioflags /*in,out*/, const uint8_t **pp, H5T_t
                 if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, actual_name_length, p_end))
                     HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
 
+                /* Check for duplicated field name */
+                for (memb_idx = 0; memb_idx < dt->shared->u.compnd.nmembs; memb_idx++)
+                    if (0 == strcmp((const char *)*pp, dt->shared->u.compnd.memb[memb_idx].name))
+                        HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, FAIL,
+                                    "duplicated compound field name '%s', for fields %u and %u",
+                                    (const char *)*pp, memb_idx, dt->shared->u.compnd.nmembs);
+
                 /* Decode the field name */
                 if (NULL == (dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =
                                  H5MM_xstrdup((const char *)*pp)))
@@ -509,6 +517,18 @@ H5O__dtype_decode_helper(unsigned *ioflags /*in,out*/, const uint8_t **pp, H5T_t
                 if (version == H5O_DTYPE_VERSION_1) {
                     /* Check if this member is an array field */
                     if (ndims > 0) {
+                        /* Validate decoded dims */
+                        for (unsigned u = 0; u < ndims; u++)
+                            if (!(dim[u] > 0)) {
+                                dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =
+                                    H5MM_xfree(dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name);
+                                if (H5T_close_real(temp_type) < 0)
+                                    HDONE_ERROR(H5E_DATATYPE, H5E_CANTRELEASE, FAIL,
+                                                "can't release datatype info");
+                                HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL,
+                                            "zero-sized dimension specified");
+                            }
+
                         /* Create the array datatype for the field */
                         if ((array_dt = H5T__array_create(temp_type, ndims, dim)) == NULL) {
                             dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =