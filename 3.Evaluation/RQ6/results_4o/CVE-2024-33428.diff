diff --git a/src/afilter/conv.c b/src/afilter/conv.c
--- a/src/afilter/conv.c
+++ b/src/afilter/conv.c
@@ -103,6 +103,12 @@
 	if (r != 0)
 		return PHI_ERR;
 
+	// Allow no more than 16MB per 1 second of 64-bit 7.1 audio: 0x00ffffff/(64/8*8)=262143
+	if (c->fo.rate > 262143) {
+		errlog(t, "too large sample rate: %u", c->fo.rate);
+		return PHI_ERR;
+	}
+
 	uint out_ch = c->fo.channels & PHI_PCM_CHMASK;
 	c->out_samp_size = pcm_size(c->fo.format, out_ch);
diff --git a/src/format/wav.c b/src/format/wav.c
--- a/src/format/wav.c
+++ b/src/format/wav.c
@@ -65,8 +65,11 @@
 	return wf;
 }
 
-static void wav_info(struct wav_r *w, phi_track *t, const struct wav_info *ai)
+static int wav_info(struct wav_r *w, phi_track *t, const struct wav_info *ai)
 {
+	if (ai->channels > 8)
+		return -1;
+
 	t->audio.decoder = "WAVE";
 	struct phi_af f = {
 		.format = af_wav_phi(ai->format),
@@ -78,6 +81,7 @@
 	t->audio.total = ai->total_samples;
 	t->audio.bitrate = ai->bitrate;
 	t->data_type = "pcm";
+	return 0;
 }
 
 static int wav_process(void *ctx, phi_track *t)
@@ -129,7 +133,10 @@
 			goto data;
 
 		case WAVREAD_HEADER:
-			wav_info(w, t, wavread_info(&w->wav));
+			if (wav_info(w, t, wavread_info(&w->wav))) {
+				errlog(t, "incorrect WAV header");
+				return PHI_ERR;
+			}
 
 			if (t->conf.info_only)
 				return PHI_LASTOUT;