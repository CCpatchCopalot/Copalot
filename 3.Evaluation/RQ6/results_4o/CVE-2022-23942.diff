diff --git a/be/src/exprs/encryption_functions.cpp b/be/src/exprs/encryption_functions.cpp
--- a/be/src/exprs/encryption_functions.cpp
+++ b/be/src/exprs/encryption_functions.cpp
@@ -55,32 +55,23 @@
     if (src.len == 0 || src.is_null) {
         return StringVal::null();
     }
+    /*
+     * Buffer for ciphertext. Ensure the buffer is long enough for the
+     * ciphertext which may be longer than the plaintext, depending on the
+     * algorithm and mode.
+     */
+
     int cipher_len = src.len + 16;
-    std::unique_ptr<char[]> p;
-    p.reset(new char[cipher_len]);
-    int ret_code = 0;
-    if (mode != AES_128_ECB && mode != AES_192_ECB && mode != AES_256_ECB && mode != AES_256_ECB &&
-        mode != SM4_128_ECB) {
-        if (iv.len == 0 || iv.is_null) {
-            return StringVal::null();
-        }
-        int iv_len = 32; // max  key length 256 / 8
-        std::unique_ptr<char[]> init_vec;
-        init_vec.reset(new char[iv_len]);
-        std::memset(init_vec.get(), 0, iv.len + 1);
-        memcpy(init_vec.get(), iv.ptr, iv.len);
-        ret_code = EncryptionUtil::encrypt(
-                mode, (unsigned char*)src.ptr, src.len, (unsigned char*)key.ptr, key.len,
-                (unsigned char*)init_vec.get(), true, (unsigned char*)p.get());
-    } else {
-        ret_code = EncryptionUtil::encrypt(mode, (unsigned char*)src.ptr, src.len,
-                                           (unsigned char*)key.ptr, key.len, nullptr, true,
-                                           (unsigned char*)p.get());
-    }
-    if (ret_code < 0) {
+    std::unique_ptr<char[]> cipher_text;
+    cipher_text.reset(new char[cipher_len]);
+    int cipher_text_len = 0;
+    cipher_text_len = EncryptionUtil::encrypt(mode, (unsigned char*)src.ptr, src.len,
+                                              (unsigned char*)key.ptr, key.len, (char*)iv.ptr, true,
+                                              (unsigned char*)cipher_text.get());
+    if (cipher_text_len < 0) {
         return StringVal::null();
     }
-    return AnyValUtil::from_buffer_temp(ctx, p.get(), ret_code);
+    return AnyValUtil::from_buffer_temp(ctx, cipher_text.get(), cipher_text_len);
 }
 
 StringVal decrypt(FunctionContext* ctx, const StringVal& src, const StringVal& key,
@@ -89,31 +80,16 @@
         return StringVal::null();
     }
     int cipher_len = src.len;
-    std::unique_ptr<char[]> p;
-    p.reset(new char[cipher_len]);
-    int ret_code = 0;
-    if (mode != AES_128_ECB && mode != AES_192_ECB && mode != AES_256_ECB && mode != AES_256_ECB &&
-        mode != SM4_128_ECB) {
-        if (iv.len == 0 || iv.is_null) {
-            return StringVal::null();
-        }
-        int iv_len = 32; // max  key length 256 / 8
-        std::unique_ptr<char[]> init_vec;
-        init_vec.reset(new char[iv_len]);
-        std::memset(init_vec.get(), 0, iv.len + 1);
-        memcpy(init_vec.get(), iv.ptr, iv.len);
-        ret_code = EncryptionUtil::decrypt(
-                mode, (unsigned char*)src.ptr, src.len, (unsigned char*)key.ptr, key.len,
-                (unsigned char*)init_vec.get(), true, (unsigned char*)p.get());
-    } else {
-        ret_code = EncryptionUtil::decrypt(mode, (unsigned char*)src.ptr, src.len,
-                                           (unsigned char*)key.ptr, key.len, nullptr, true,
-                                           (unsigned char*)p.get());
-    }
-    if (ret_code < 0) {
+    std::unique_ptr<char[]> plain_text;
+    plain_text.reset(new char[cipher_len]);
+    int plain_text_len = 0;
+    plain_text_len =
+            EncryptionUtil::decrypt(mode, (unsigned char*)src.ptr, src.len, (unsigned char*)key.ptr,
+                                    key.len, (char*)iv.ptr, true, (unsigned char*)plain_text.get());
+    if (plain_text_len < 0) {
         return StringVal::null();
     }
-    return AnyValUtil::from_buffer_temp(ctx, p.get(), ret_code);
+    return AnyValUtil::from_buffer_temp(ctx, plain_text.get(), plain_text_len);
 }
 
diff --git a/be/src/util/encryption_util.cpp b/be/src/util/encryption_util.cpp
--- a/be/src/util/encryption_util.cpp
+++ b/be/src/util/encryption_util.cpp
@@ -171,20 +173,29 @@
 
 int EncryptionUtil::encrypt(EncryptionMode mode, const unsigned char* source,
                             uint32_t source_length, const unsigned char* key, uint32_t key_length,
-                            const unsigned char* iv, bool padding, unsigned char* encrypt) {
+                            const char* iv_str, bool padding, unsigned char* encrypt) {
     const EVP_CIPHER* cipher = get_evp_type(mode);
     /* The encrypt key to be used for encryption */
     unsigned char encrypt_key[ENCRYPTION_MAX_KEY_LENGTH / 8];
     create_key(key, key_length, encrypt_key, mode);
 
-    if (cipher == nullptr || (EVP_CIPHER_iv_length(cipher) > 0 && !iv)) {
+    int iv_length = EVP_CIPHER_iv_length(cipher);
+    if (cipher == nullptr || (iv_length > 0 && !iv_str)) {
         return AES_BAD_DATA;
     }
+    char* init_vec = nullptr;
+    std::string iv_default("DORISDORISDORIS_");
+
+    if (iv_str) {
+        init_vec = &iv_default[0];
+        memcpy(init_vec, iv_str, strnlen(iv_str, EVP_MAX_IV_LENGTH));
+        init_vec[iv_length] = '\0';
+    }
     EVP_CIPHER_CTX* cipher_ctx = EVP_CIPHER_CTX_new();
     EVP_CIPHER_CTX_reset(cipher_ctx);
     int length = 0;
-    int ret = do_encrypt(cipher_ctx, cipher, source, source_length, encrypt_key, iv, padding,
-                         encrypt, &length);
+    int ret = do_encrypt(cipher_ctx, cipher, source, source_length, encrypt_key,
+                         reinterpret_cast<unsigned char*>(init_vec), padding, encrypt, &length);
     EVP_CIPHER_CTX_free(cipher_ctx);
     if (ret == 0) {
         ERR_clear_error();
@@ -219,21 +230,31 @@
 
 int EncryptionUtil::decrypt(EncryptionMode mode, const unsigned char* encrypt,
                             uint32_t encrypt_length, const unsigned char* key, uint32_t key_length,
-                            const unsigned char* iv, bool padding, unsigned char* decrypt_content) {
+                            const char* iv_str, bool padding, unsigned char* decrypt_content) {
     const EVP_CIPHER* cipher = get_evp_type(mode);
 
     /* The encrypt key to be used for decryption */
     unsigned char encrypt_key[ENCRYPTION_MAX_KEY_LENGTH / 8];
     create_key(key, key_length, encrypt_key, mode);
 
-    if (cipher == nullptr || (EVP_CIPHER_iv_length(cipher) > 0 && !iv)) {
+    int iv_length = EVP_CIPHER_iv_length(cipher);
+    if (cipher == nullptr || (iv_length > 0 && !iv_str)) {
         return AES_BAD_DATA;
     }
+    char* init_vec = nullptr;
+    std::string iv_default("DORISDORISDORIS_");
+
+    if (iv_str) {
+        init_vec = &iv_default[0];
+        memcpy(init_vec, iv_str, strnlen(iv_str, EVP_MAX_IV_LENGTH));
+        init_vec[iv_length] = '\0';
+    }
     EVP_CIPHER_CTX* cipher_ctx = EVP_CIPHER_CTX_new();
     EVP_CIPHER_CTX_reset(cipher_ctx);
     int length = 0;
-    int ret = do_decrypt(cipher_ctx, cipher, encrypt, encrypt_length, encrypt_key, iv, padding,
-                         decrypt_content, &length);
+    int ret = do_decrypt(cipher_ctx, cipher, encrypt, encrypt_length, encrypt_key,
+                         reinterpret_cast<unsigned char*>(init_vec), padding, decrypt_content,
+                         &length);
     EVP_CIPHER_CTX_free(cipher_ctx);
     if (ret > 0) {
diff --git a/be/src/util/encryption_util.h b/be/src/util/encryption_util.h
--- a/be/src/util/encryption_util.h
+++ b/be/src/util/encryption_util.h
@@ -58,11 +58,11 @@
 class EncryptionUtil {
 public:
     static int encrypt(EncryptionMode mode, const unsigned char* source, uint32_t source_length,
-                       const unsigned char* key, uint32_t key_length, const unsigned char* iv,
+                       const unsigned char* key, uint32_t key_length, const char* iv_str,
                        bool padding, unsigned char* encrypt);
 
     static int decrypt(EncryptionMode mode, const unsigned char* encrypt, uint32_t encrypt_length,
-                       const unsigned char* key, uint32_t key_length, const unsigned char* iv,
+                       const unsigned char* key, uint32_t key_length, const char* iv_str,
                        bool padding, unsigned char* decrypt_content);
 };
 
