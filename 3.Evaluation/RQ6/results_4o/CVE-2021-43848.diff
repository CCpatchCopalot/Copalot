diff --git a/lib/http3/server.c b/lib/http3/server.c
index 8fa9070ad4..8a6ac20b76 100644
--- a/lib/http3/server.c
+++ b/lib/http3/server.c
@@ -834,7 +834,7 @@ static void handle_buffered_input(struct st_h2o_http3_server_stream_t *stream, i
         while (src != src_end) {
             int err;
             const char *err_desc = NULL;
-            if ((err = stream->recvbuf.handle_input(stream, &src, src_end, &err_desc)) != 0) {
+            if ((err = stream->recvbuf.handle_input(stream, &src, src_end, in_generator, &err_desc)) != 0) {
                 if (err == H2O_HTTP3_ERROR_INCOMPLETE) {
                     if (!quicly_recvstate_transfer_complete(&stream->quic->recvstate))
                         break;
@@ -1102,7 +1102,7 @@ int handle_input_expect_data(struct st_h2o_http3_server_stream_t *stream, const
             stream->req.content_length - stream->req.req_body_bytes_received < frame.length) {
             /* The only viable option here is to reset the stream, as we might have already started streaming the request body
              * upstream. This behavior is consistent with what we do in HTTP/2. */
-            shutdown_stream(stream, H2O_HTTP3_ERROR_EARLY_RESPONSE, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, 0);
+            shutdown_stream(stream, H2O_HTTP3_ERROR_EARLY_RESPONSE, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, in_generator);
             return 0;
         }
         break;
@@ -1134,6 +1134,8 @@ static int handle_input_expect_headers_send_http_error(struct st_h2o_http3_serve
 }
 
 static int handle_input_expect_headers(struct st_h2o_http3_server_stream_t *stream, const uint8_t **src, const uint8_t *src_end,
-                                       const char **err_desc)
+                                       int in_generator, const char **err_desc)
 {
+    assert(!in_generator); /* this function is processing headers (before generators get assigned), not trailers */
+
     struct st_h2o_http3_server_conn_t *conn = get_conn(stream);
     h2o_http3_read_frame_t frame;