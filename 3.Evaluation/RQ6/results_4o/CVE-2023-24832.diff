diff --git a/include/hermes/BCGen/HBC/BytecodeProviderFromSrc.h b/include/hermes/BCGen/HBC/BytecodeProviderFromSrc.h
--- a/include/hermes/BCGen/HBC/BytecodeProviderFromSrc.h
+++ b/include/hermes/BCGen/HBC/BytecodeProviderFromSrc.h
@@ -219,7 +219,7 @@
 
   /// No debug information will be available without compiling it.
   void createDebugInfo() override {
-    llvm_unreachable("Accessing debug info from a lazy module");
+    hermes_fatal("Accessing debug info from a lazy module");
   }
 
diff --git a/lib/VM/JSLib/HermesInternal.cpp b/lib/VM/JSLib/HermesInternal.cpp
--- a/lib/VM/JSLib/HermesInternal.cpp
+++ b/lib/VM/JSLib/HermesInternal.cpp
@@ -574,14 +574,18 @@
     const CodeBlock *codeBlock,
     OptValue<hbc::DebugSourceLocation> location) {
   RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();
-  if (location) {
-    auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();
-    return StringPrimitive::createEfficient(
-        runtime, debugInfo->getFilenameByID(location->filenameId));
-  } else {
-    llvh::StringRef sourceURL = runtimeModule->getSourceURL();
-    if (!sourceURL.empty()) {
-      return StringPrimitive::createEfficient(runtime, sourceURL);
+  if (!runtimeModule->getBytecode()->isLazy()) {
+    // Lazy code blocks do not have debug information (and will hermes_fatal if
+    // you try to access it), so only touch it for non-lazy blocks.
+    if (location) {
+      auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();
+      return StringPrimitive::createEfficient(
+          runtime, debugInfo->getFilenameByID(location->filenameId));
+    } else {
+      llvh::StringRef sourceURL = runtimeModule->getSourceURL();
+      if (!sourceURL.empty()) {
+        return StringPrimitive::createEfficient(runtime, sourceURL);
+      }
     }
   }
   return HermesValue::encodeUndefinedValue();