diff --git a/component/common/network/dhcp/dhcps.c b/component/common/network/dhcp/dhcps.c
--- a/component/common/network/dhcp/dhcps.c
+++ b/component/common/network/dhcp/dhcps.c
@@ -73,7 +73,7 @@
 		printf("\r\n ip_table.ip_range[3] = 0x%x\r\n",ip_table.ip_range[3]);
 #endif	
 	} else if(128 < d && d <= 160) {
-		ip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, d);	
+		ip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, (d - 128));	
 #if (debug_dhcps)		
 		printf("\r\n ip_table.ip_range[4] = 0x%x\r\n",ip_table.ip_range[4]);
 #endif	
@@ -154,6 +154,82 @@
 Exit:
 	return ip_addr4;
 }
+
+static uint8_t check_client_direct_request_ip(struct ip_addr *client_req_ip, uint8_t *hwaddr)
+{
+	int ip_addr4 = 0, i;
+
+#if (debug_dhcps)	
+#if LWIP_VERSION_MAJOR >= 2
+	printf("\r\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n", __func__,
+			ip4_addr1(ip_2_ip4(client_req_ip)), ip4_addr2(ip_2_ip4(client_req_ip)), ip4_addr3(ip_2_ip4(client_req_ip)), ip4_addr4(ip_2_ip4(client_req_ip)),
+			hwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);
+#else
+	printf("\r\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n", __func__,
+			ip4_addr1(client_req_ip), ip4_addr2(client_req_ip), ip4_addr3(client_req_ip), ip4_addr4(client_req_ip),
+			hwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);
+#endif	
+#endif
+
+#if LWIP_VERSION_MAJOR >= 2
+	if( (ip4_addr1(ip_2_ip4(&dhcps_network_id)) != ip4_addr1(ip_2_ip4(client_req_ip))) ||
+		(ip4_addr2(ip_2_ip4(&dhcps_network_id)) != ip4_addr2(ip_2_ip4(client_req_ip))) ||
+		(ip4_addr3(ip_2_ip4(&dhcps_network_id)) != ip4_addr3(ip_2_ip4(client_req_ip))))
+#else
+	if( (ip4_addr1(&dhcps_network_id) != ip4_addr1(client_req_ip)) ||
+		(ip4_addr2(&dhcps_network_id) != ip4_addr2(client_req_ip)) ||
+		(ip4_addr3(&dhcps_network_id) != ip4_addr3(client_req_ip)))
+#endif
+
+	{
+		ip_addr4 = 0;
+		goto Exit;
+	}
+
+	// check if the requested ip is available
+#if LWIP_VERSION_MAJOR >= 2
+	ip_addr4 = ip4_addr4(ip_2_ip4(client_req_ip));
+#else
+	ip_addr4 = ip4_addr4(client_req_ip);
+#endif
+
+	if (ip_addr4 < DHCP_POOL_START || ip_addr4 > DHCP_POOL_END) {
+		ip_addr4 = 0;
+		goto Exit;
+	}
+	xSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);
+	printf("ip_table[%d] = %x,%x,%x,%x,%x,%x\n",ip_addr4,ip_table.client_mac[ip_addr4][0],
+										  			     ip_table.client_mac[ip_addr4][1],
+										  				 ip_table.client_mac[ip_addr4][2],
+										  				 ip_table.client_mac[ip_addr4][3],
+										  				 ip_table.client_mac[ip_addr4][4],
+										  				 ip_table.client_mac[ip_addr4][5]);
+	if(	(	ip_table.client_mac[ip_addr4][0] == 0 &&
+			ip_table.client_mac[ip_addr4][1] == 0 &&
+			ip_table.client_mac[ip_addr4][2] == 0 &&
+			ip_table.client_mac[ip_addr4][3] == 0 &&
+			ip_table.client_mac[ip_addr4][4] == 0 &&
+			ip_table.client_mac[ip_addr4][5] == 0) ||
+		(	ip_table.client_mac[ip_addr4][0] == hwaddr[0] &&
+			ip_table.client_mac[ip_addr4][1] == hwaddr[1] &&
+			ip_table.client_mac[ip_addr4][2] == hwaddr[2] &&
+			ip_table.client_mac[ip_addr4][3] == hwaddr[3] &&
+			ip_table.client_mac[ip_addr4][4] == hwaddr[4] &&
+			ip_table.client_mac[ip_addr4][5] == hwaddr[5]))
+	{
+		// the ip is available or already allocated to this client
+	}
+	else
+	{
+		ip_addr4 = 0; // the ip is used
+	}
+	
+	xSemaphoreGive(dhcps_ip_table_semaphore);
+
+Exit:
+	return ip_addr4;
+}
+
 static void dump_client_table()
 {
 #if 0
@@ -338,55 +414,101 @@
 /**
   * @brief  fill in the needed content of the dhcp offer message. 
   * @param  optptr  the addr which the tail of dhcp magic field. 
-  * @retval the addr represent to add the end of option.
+  * @retval	0, add ok
+  *			-1, add fail
   */
-static void add_offer_options(uint8_t *option_start_address)
+static int8_t add_offer_options(uint8_t *option_start_address)
 {
-	uint8_t *temp_option_addr;
+	// Total minimum len = 6+6+6+6+6+6+4+3+1 = 44
+	uint8_t *temp_option_addr = option_start_address;
+	int max_addable_option_len = dhcp_message_total_options_lenth - 4 - 3;	// -magic-type
+
+	if(option_start_address == NULL)
+		goto ERROR;
+
 	/* add DHCP options 1. 
 	The subnet mask option specifies the client's subnet mask */
-	temp_option_addr = fill_one_option_content(option_start_address,
-			DHCP_OPTION_CODE_SUBNET_MASK, DHCP_OPTION_LENGTH_FOUR,
-					(void *)&dhcps_local_mask);
+	if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {
+		temp_option_addr = fill_one_option_content(option_start_address, DHCP_OPTION_CODE_SUBNET_MASK,
+						DHCP_OPTION_LENGTH_FOUR,(void *)&dhcps_local_mask);
+	}else{
+		goto ERROR;
+	}
 	
         /* add DHCP options 3 (i.e router(gateway)). The time server option 
         specifies a list of RFC 868 [6] time servers available to the client. */
-	temp_option_addr = fill_one_option_content(temp_option_addr,
-			DHCP_OPTION_CODE_ROUTER, DHCP_OPTION_LENGTH_FOUR,
-					(void *)&dhcps_local_address);
+        if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {
+		temp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_ROUTER,
+						DHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);
+	}else{
+		goto ERROR;
+	}
 
 	/* add DHCP options 6 (i.e DNS). 
         The option specifies a list of DNS servers available to the client. */
-	temp_option_addr = fill_one_option_content(temp_option_addr,
-			DHCP_OPTION_CODE_DNS_SERVER, DHCP_OPTION_LENGTH_FOUR,
-					(void *)&dhcps_local_address);	
+	 if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {
+	 	temp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_DNS_SERVER,
+						DHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);	
+	}else{
+		goto ERROR;
+	}
+	
 	/* add DHCP options 51.
 	This option is used to request a lease time for the IP address. */
-	temp_option_addr = fill_one_option_content(temp_option_addr,
-			DHCP_OPTION_CODE_LEASE_TIME, DHCP_OPTION_LENGTH_FOUR,
-					(void *)&dhcp_option_lease_time);
+	 if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {
+		temp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_LEASE_TIME,
+						DHCP_OPTION_LENGTH_FOUR, (void *)&dhcp_option_lease_time);
+	}else{
+		goto ERROR;
+	}
+	
 	/* add DHCP options 54. 
 	The identifier is the IP address of the selected server. */
-	temp_option_addr = fill_one_option_content(temp_option_addr,
-			DHCP_OPTION_CODE_SERVER_ID, DHCP_OPTION_LENGTH_FOUR,
-				(void *)&dhcps_local_address);
+	 if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {
+		temp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_SERVER_ID,
+						DHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);
+	}else{
+		goto ERROR;
+	}
+	
 	/* add DHCP options 28. 
 	This option specifies the broadcast address in use on client's subnet.*/
-	temp_option_addr = fill_one_option_content(temp_option_addr,
-		DHCP_OPTION_CODE_BROADCAST_ADDRESS, DHCP_OPTION_LENGTH_FOUR,
-				(void *)&dhcps_subnet_broadcast);
+	if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {
+		temp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_BROADCAST_ADDRESS,
+						DHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_subnet_broadcast);
+	}else{
+		goto ERROR;
+	}
+	
 	/* add DHCP options 26. 
 	This option specifies the Maximum transmission unit to use */
-	temp_option_addr = fill_one_option_content(temp_option_addr,
-		DHCP_OPTION_CODE_INTERFACE_MTU, DHCP_OPTION_LENGTH_TWO,
-					(void *) &dhcp_option_interface_mtu);//dhcp_option_interface_mtu_576);
+	if(temp_option_addr + 4 -option_start_address <= max_addable_option_len) {
+		temp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_INTERFACE_MTU,
+						DHCP_OPTION_LENGTH_TWO, (void *) &dhcp_option_interface_mtu);//dhcp_option_interface_mtu_576);
+	}else{
+		goto ERROR;
+	}
+	
 	/* add DHCP options 31.
 	This option specifies whether or not the client should solicit routers */
-	temp_option_addr = fill_one_option_content(temp_option_addr,
-		DHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY, DHCP_OPTION_LENGTH_ONE,
-								NULL);
+	if(temp_option_addr + 3 -option_start_address <= max_addable_option_len) {
+		temp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY,
+						DHCP_OPTION_LENGTH_ONE,	NULL);
+	}else{
+		goto ERROR;
+	}
+
+	// END
+	if(temp_option_addr + 1 -option_start_address <= max_addable_option_len) {
 	*temp_option_addr++ = DHCP_OPTION_CODE_END;
+	}else{
+		goto ERROR;
+	}
+	return 0;
 
+ERROR:
+	printf("\r\n[%s] error: add options fail !!", __func__);
+	return -1;
 }
