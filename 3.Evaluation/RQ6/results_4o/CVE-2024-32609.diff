diff --git a/src/H5Dcompact.c b/src/H5Dcompact.c
index 864d4963a6e..de84034f638 100644
--- a/src/H5Dcompact.c
+++ b/src/H5Dcompact.c
@@ -58,6 +58,7 @@ typedef struct H5D_compact_iovv_memmanage_ud_t {
 
 /* Layout operation callbacks */
 static herr_t  H5D__compact_construct(H5F_t *f, H5D_t *dset);
+static herr_t  H5D__compact_init(H5F_t *f, const H5D_t *dset, hid_t dapl_id);
 static bool    H5D__compact_is_space_alloc(const H5O_storage_t *storage);
 static herr_t  H5D__compact_io_init(H5D_io_info_t *io_info, H5D_dset_io_info_t *dinfo);
 static herr_t  H5D__compact_iovv_memmanage_cb(hsize_t dst_off, hsize_t src_off, size_t len, void *_udata);
@@ -79,7 +80,7 @@ static herr_t  H5D__compact_dest(H5D_t *dset);
 /* Compact storage layout I/O ops */
 const H5D_layout_ops_t H5D_LOPS_COMPACT[1] = {{
     H5D__compact_construct,      /* construct */
-    NULL,                        /* init */
+    H5D__compact_init,           /* init */
     H5D__compact_is_space_alloc, /* is_space_alloc */
     NULL,                        /* is_data_cached */
     H5D__compact_io_init,        /* io_init */
@@ -198,6 +199,63 @@ H5D__compact_construct(H5F_t *f, H5D_t *dset)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__compact_construct() */
 
+/*-------------------------------------------------------------------------
+ * Function:	H5D__compact_init
+ *
+ * Purpose:	Initialize the info for a compact dataset.  This is
+ *		called when the dataset is initialized.
+ *
+ * Return:	Non-negative on success/Negative on failure
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+H5D__compact_init(H5F_t H5_ATTR_UNUSED *f, const H5D_t *dset, hid_t H5_ATTR_UNUSED dapl_id)
+{
+    hssize_t snelmts;             /* Temporary holder for number of elements in dataspace */
+    hsize_t  nelmts;              /* Number of elements in dataspace */
+    size_t   dt_size;             /* Size of datatype */
+    hsize_t  data_size;           /* Dataset size, in bytes */
+    herr_t   ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* Sanity check */
+    assert(dset);
+    assert(H5D_COMPACT == dset->shared->layout.storage.type);
+
+    /*
+     * Now that we've read the dataset's datatype, dataspace and
+     * layout information, perform a quick check for compact datasets
+     * to ensure that the size of the internal buffer that was
+     * allocated for the dataset's raw data matches the size of
+     * the data. A corrupted file can cause a mismatch between the
+     * two, which might result in buffer overflows during future
+     * I/O to the dataset.
+     */
+    if (0 == (dt_size = H5T_GET_SIZE(dset->shared->type)))
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get datatype size");
+    if ((snelmts = H5S_GET_EXTENT_NPOINTS(dset->shared->space)) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get number of elements in dataset's dataspace");
+    nelmts = (hsize_t)snelmts;
+
+    /* Compute the size of the dataset's contiguous storage */
+    data_size = nelmts * dt_size;
+
+    /* Check for overflow during multiplication */
+    if (nelmts != (data_size / dt_size))
+        HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "size of dataset's storage overflowed");
+
+    /* Check for mismatch */
+    if (dset->shared->layout.storage.u.compact.size != data_size)
+        HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL,
+                    "bad value from dataset header - size of compact dataset's data buffer doesn't match "
+                    "size of dataset data");
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5D__compact_init() */
+
 /*-------------------------------------------------------------------------
  * Function:	H5D__compact_is_space_alloc
diff --git a/src/H5Dcontig.c b/src/H5Dcontig.c
index d9137b9479a..11b0a8e4ef8 100644
--- a/src/H5Dcontig.c
+++ b/src/H5Dcontig.c
@@ -356,6 +356,65 @@ H5D__contig_delete(H5F_t *f, const H5O_storage_t *store)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__contig_delete */
 
+/*-------------------------------------------------------------------------
+ * Function:	H5D__contig_check
+ *
+ * Purpose:	Sanity check the contiguous info for a dataset.
+ *
+ * Return:	Non-negative on success/Negative on failure
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5D__contig_check(const H5F_t *f, const H5O_layout_t *layout, const H5S_extent_t *extent, const H5T_t *dt)
+{
+    hsize_t nelmts;              /* Number of elements in dataspace */
+    size_t  dt_size;             /* Size of datatype */
+    hsize_t data_size;           /* Raw data size */
+    herr_t  ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* Sanity check */
+    assert(f);
+    assert(layout);
+    assert(extent);
+    assert(dt);
+
+    /* Retrieve the number of elements in the dataspace */
+    nelmts = H5S_extent_nelem(extent);
+
+    /* Get the datatype's size */
+    if (0 == (dt_size = H5T_GET_SIZE(dt)))
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve size of datatype");
+
+    /* Compute the size of the dataset's contiguous storage */
+    data_size = nelmts * dt_size;
+
+    /* Check for overflow during multiplication */
+    if (nelmts != (data_size / dt_size))
+        HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "size of dataset's storage overflowed");
+
+    /* Check for invalid (corrupted in the file, probably) dimensions */
+    if (H5_addr_defined(layout->storage.u.contig.addr)) {
+        haddr_t rel_eoa; /* Relative end of file address	*/
+
+        if (HADDR_UNDEF == (rel_eoa = H5F_get_eoa(f, H5FD_MEM_DRAW)))
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to determine file size");
+
+        /* Check for invalid dataset size (from bad dimensions) putting the
+         * dataset elements off the end of the file
+         */
+        if (H5_addr_le((layout->storage.u.contig.addr + data_size), layout->storage.u.contig.addr))
+            HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "invalid dataset size, likely file corruption");
+        if (H5_addr_gt((layout->storage.u.contig.addr + data_size), rel_eoa))
+            HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "invalid dataset size, likely file corruption");
+    }
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5D__contig_check() */
+
 /*-------------------------------------------------------------------------
  * Function:	H5D__contig_construct
diff --git a/src/H5Gnode.c b/src/H5Gnode.c
index b4bd1214bf8..f211e74e041 100644
--- a/src/H5Gnode.c
+++ b/src/H5Gnode.c
@@ -344,6 +344,7 @@ H5G__node_cmp2(void *_lt_key, void *_udata, void *_rt_key)
     H5G_node_key_t  *lt_key = (H5G_node_key_t *)_lt_key;
     H5G_node_key_t  *rt_key = (H5G_node_key_t *)_rt_key;
     const char      *s1, *s2;
+    size_t           max_len;
     int              ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
@@ -359,8 +360,14 @@ H5G__node_cmp2(void *_lt_key, void *_udata, void *_rt_key)
     if ((s2 = (const char *)H5HL_offset_into(udata->heap, rt_key->offset)) == NULL)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get key name");
 
+    /* Compute maximum length of string to compare */
+    if (rt_key->offset > lt_key->offset)
+        max_len = udata->block_size - rt_key->offset;
+    else
+        max_len = udata->block_size - lt_key->offset;
+
     /* Set return value */
-    ret_value = strcmp(s1, s2);
+    ret_value = strncmp(s1, s2, max_len);
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
@@ -406,13 +413,13 @@ H5G__node_cmp3(void *_lt_key, void *_udata, void *_rt_key)
     /* left side */
     if ((s = (const char *)H5HL_offset_into(udata->heap, lt_key->offset)) == NULL)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get key name");
-    if (strcmp(udata->name, s) <= 0)
+    if (strncmp(udata->name, s, (udata->block_size - lt_key->offset)) <= 0)
         ret_value = (-1);
     else {
         /* right side */
         if ((s = (const char *)H5HL_offset_into(udata->heap, rt_key->offset)) == NULL)
             HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get key name");
-        if (strcmp(udata->name, s) > 0)
+        if (strncmp(udata->name, s, (udata->block_size - rt_key->offset)) > 0)
             ret_value = 1;
     } /* end else */
diff --git a/src/H5HL.c b/src/H5HL.c
index 680ef0a15db..f6e589b016d 100644
--- a/src/H5HL.c
+++ b/src/H5HL.c
@@ -295,13 +295,15 @@ H5HL_protect(H5F_t *f, haddr_t addr, unsigned flags)
 {
     H5HL_cache_prfx_ud_t prfx_udata;                /* User data for protecting local heap prefix       */
     H5HL_prfx_t         *prfx = NULL;               /* Local heap prefix                                */
     H5HL_dblk_t         *dblk = NULL;               /* Local heap data block                            */
     H5HL_t              *heap = NULL;               /* Heap data structure                              */
     unsigned prfx_cache_flags = H5AC__NO_FLAGS_SET; /* Cache flags for unprotecting prefix entry        */
     unsigned dblk_cache_flags = H5AC__NO_FLAGS_SET; /* Cache flags for unprotecting data block entry    */
     H5HL_t  *ret_value        = NULL;
+    bool     is_pinned        = false; /* Whether the heap is pinned in memory */
 
     FUNC_ENTER_PACKAGE
 
     /* check arguments */
     assert(f);
     assert(H5_addr_defined(addr));
 
@@ -328,19 +330,25 @@ H5HL_protect(H5F_t *f, haddr_t addr, unsigned flags)
     /* Check if the heap is already pinned in memory */
     /* (for re-entrant situation) */
     if (heap->prots == 0) {
+        void *pin_obj; /* Pointer to local heap object to pin */
+
         /* Check if heap has separate data block */
         if (heap->single_cache_obj)
-            /* Set the flag for pinning the prefix when unprotecting it */
-            prfx_cache_flags |= H5AC__PIN_ENTRY_FLAG;
+            /* Pin prefix */
+            pin_obj = prfx;
         else {
             /* Protect the local heap data block */
             if (NULL ==
                 (dblk = (H5HL_dblk_t *)H5AC_protect(f, H5AC_LHEAP_DBLK, heap->dblk_addr, heap, flags)))
                 HGOTO_ERROR(H5E_HEAP, H5E_CANTPROTECT, NULL, "unable to load heap data block");
 
-            /* Set the flag for pinning the data block when unprotecting it */
-            dblk_cache_flags |= H5AC__PIN_ENTRY_FLAG;
+            /* Pin data block */
+            pin_obj = dblk;
         }
+
+        /* Pin local heap object */
+        if (H5AC_pin_protected_entry(pin_obj) < 0)
+            HGOTO_ERROR(H5E_HEAP, H5E_CANTPIN, NULL, "unable to pin local heap object");
     }
 
     /* Increment # of times heap is protected */
@@ -351,11 +359,11 @@ H5HL_protect(H5F_t *f, haddr_t addr, unsigned flags)
 
 done:
     /* Release the prefix from the cache, now pinned */
-    if (prfx && heap && H5AC_unprotect(f, H5AC_LHEAP_PRFX, heap->prfx_addr, prfx, prfx_cache_flags) < 0)
+    if (prfx && heap && H5AC_unprotect(f, H5AC_LHEAP_PRFX, heap->prfx_addr, prfx, H5AC__NO_FLAGS_SET) < 0)
         HDONE_ERROR(H5E_HEAP, H5E_CANTUNPROTECT, NULL, "unable to release local heap prefix");
 
     /* Release the data block from the cache, now pinned */
-    if (dblk && heap && H5AC_unprotect(f, H5AC_LHEAP_DBLK, heap->dblk_addr, dblk, dblk_cache_flags) < 0)
+    if (dblk && heap && H5AC_unprotect(f, H5AC_LHEAP_DBLK, heap->dblk_addr, dblk, H5AC__NO_FLAGS_SET) < 0)
         HDONE_ERROR(H5E_HEAP, H5E_CANTUNPROTECT, NULL, "unable to release local heap data block");
 
diff --git a/src/H5HG.c b/src/H5HG.c
index 3709c705566..a859b40f100 100644
--- a/src/H5HG.c
+++ b/src/H5HG.c
@@ -556,6 +556,11 @@ H5HG_read(H5F_t *f, H5HG_t *hobj, void *object /*out*/, size_t *buf_size)
     assert(f);
     assert(hobj);
 
+    /* Heap object idx 0 is the free space in the heap and should never be given out */
+    if (0 == hobj->idx)
+        HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, NULL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
+                    hobj->addr, hobj->idx);
+
     /* Load the heap */
     if (NULL == (heap = H5HG__protect(f, hobj->addr, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_HEAP, H5E_CANTPROTECT, NULL, "unable to protect