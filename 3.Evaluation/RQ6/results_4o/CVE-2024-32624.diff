diff --git a/src/H5Dint.c b/src/H5Dint.c
index 3b9d000f523..71ddda387c7 100644
--- a/src/H5Dint.c
+++ b/src/H5Dint.c
@@ -1673,11 +1673,12 @@ static herr_t
 H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
 {
     H5P_genplist_t *plist;                     /* Property list */
-    H5O_fill_t     *fill_prop;                 /* Pointer to dataset's fill value info */
+    H5O_fill_t     *fill_prop = NULL;          /* Pointer to dataset's fill value info */
     unsigned        alloc_time_state;          /* Allocation time state */
     htri_t          msg_exists;                /* Whether a particular type of message exists */
     bool            layout_init       = false; /* Flag to indicate that chunk information was initialized */
     bool            must_init_storage = false;
+    bool            fill_init         = false;   /* Flag to indicate that fill information was initialized */
     herr_t          ret_value         = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE_TAG(dataset->oloc.addr)
@@ -1762,6 +1763,9 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
         if (msg_exists) {
             if (NULL == H5O_msg_read(&(dataset->oloc), H5O_FILL_ID, fill_prop))
                 HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't retrieve message");
+
+            /* Indicate that the fill information was initialized */
+            fill_init = true;
         } /* end if */
         else {
             /* Set the space allocation time appropriately, based on the type of dataset storage */
@@ -1788,6 +1792,33 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
         (dataset->shared->layout.type == H5D_VIRTUAL && fill_prop->alloc_time == H5D_ALLOC_TIME_INCR))
         alloc_time_state = 1;
 
+    /* Check if there is a fill value, but no type yet */
+    if (fill_prop->buf != NULL && fill_prop->type == NULL) {
+        H5T_t *tmp_type; /* Temporary pointer to dataset's datatype */
+
+        /* Copy the dataset type into the fill value message */
+        if (NULL == (tmp_type = H5T_copy(dataset->shared->type, H5T_COPY_TRANSIENT)))
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTCOPY, FAIL, "unable to copy dataset datatype for fill value");
+
+        /* Check if conversion is necessary on fill buffer, and if fill-value
+         * buffer is too small to hold the result.
+         */
+        if (!H5T_noop_conv(dataset->shared->type, tmp_type)) {
+            size_t bkg_size = MAX(H5T_GET_SIZE(tmp_type), H5T_GET_SIZE(dataset->shared->type));
+
+            assert(fill_prop->size >= 0);
+            if ((size_t)fill_prop->size < bkg_size) {
+                if (H5T_close_real(tmp_type) < 0)
+                    HDONE_ERROR(H5E_DATASET, H5E_CANTFREE, FAIL, "Can't free temporary datatype");
+                HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL,
+                            "fill value size doesn't match dataset's datatype size");
+            }
+        }
+
+        if (H5T_close_real(tmp_type) < 0)
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTFREE, FAIL, "Can't free temporary datatype");
+    }
+
     /* Set revised fill value properties, if they are different from the defaults */
     if (H5P_fill_value_cmp(&H5D_def_dset.dcpl_cache.fill, fill_prop, sizeof(H5O_fill_t))) {
         if (H5P_set(plist, H5D_CRT_FILL_VALUE_NAME, fill_prop) < 0)
@@ -1845,6 +1876,8 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
         if (H5_addr_defined(dataset->oloc.addr) && H5O_close(&(dataset->oloc), NULL) < 0)
             HDONE_ERROR(H5E_DATASET, H5E_CLOSEERROR, FAIL, "unable to release object header");
         if (dataset->shared) {
+            if (fill_init)
+                H5O_msg_reset(H5O_FILL_ID, fill_prop);
             if (layout_init)
                 if (dataset->shared->layout.ops->dest && (dataset->shared->layout.ops->dest)(dataset) < 0)
diff --git a/src/H5T.c b/src/H5T.c
index ba93eefd1e4..e3cf451d30a 100644
--- a/src/H5T.c
+++ b/src/H5T.c
@@ -377,9 +377,10 @@ static herr_t H5T__register(H5T_pers_t pers, const char *name, H5T_t *src, H5T_t
 static htri_t H5T__compiler_conv(H5T_t *src, H5T_t *dst);
 static herr_t H5T__set_size(H5T_t *dt, size_t size);
 static herr_t H5T__close_cb(H5T_t *dt, void **request);
+static herr_t H5T__init_path_table(void);
+static bool   H5T__path_table_search(const H5T_t *src, const H5T_t *dst, int *idx, int *last_cmp);
 static H5T_path_t *H5T__path_find_real(const H5T_t *src, const H5T_t *dst, const char *name,
                                        H5T_conv_func_t *conv);
-static herr_t      H5T__path_find_init_path_table(void);
 static herr_t      H5T__path_find_init_new_path(H5T_path_t *path, const H5T_t *src, const H5T_t *dst,
                                                 H5T_conv_func_t *conv, H5T_conv_ctx_t *conv_ctx);
 static herr_t      H5T__path_free(H5T_path_t *path, H5T_conv_ctx_t *conv_ctx);
@@ -5674,6 +5698,47 @@ H5T_path_noop(const H5T_path_t *p)
     FUNC_LEAVE_NOAPI(p->is_noop || (p->is_hard && 0 == H5T_cmp(p->src, p->dst, false)))
 } /* end H5T_path_noop() */
 
+/*-------------------------------------------------------------------------
+ * Function:    H5T_noop_conv
+ *
+ * Purpose:     Check if a conversion between two dataypes will be a no-op
+ *
+ * Return:      true / false (can't fail)
+ *
+ *-------------------------------------------------------------------------
+ */
+bool
+H5T_noop_conv(const H5T_t *src, const H5T_t *dst)
+{
+    bool ret_value = false; /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT_NOERR
+
+    /* Sanity check */
+    assert(src);
+    assert(src->shared);
+    assert(dst);
+    assert(dst->shared);
+
+    /* Check the conversion path.  If source and destination types are equal
+     * then its a no-op conversion, as long as neither type has a "force conversion"
+     * flag.  Otherwise search over the conversion table entries.
+     */
+    if (src->shared->force_conv == false && dst->shared->force_conv == false &&
+        0 == H5T_cmp(src, dst, true)) {
+        ret_value = true;
+    } /* end if */
+    else {
+        int idx = 0; /* Matching entry */
+
+        /* Search the table of conversion paths */
+        if (H5T__path_table_search(src, dst, &idx, NULL))
+            ret_value = H5T_path_noop(H5T_g.path[idx]);
+    } /* end else */
+
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5T_noop_conv() */
+
 /*-------------------------------------------------------------------------
  * Function:  H5T_path_compound_subset
diff --git a/src/H5Tprivate.h b/src/H5Tprivate.h
index 46b2c92fa83..99ea256b27d 100644
--- a/src/H5Tprivate.h
+++ b/src/H5Tprivate.h
@@ -131,6 +131,7 @@ H5_DLL herr_t             H5T_convert_committed_datatype(H5T_t *dt, H5F_t *f);
 H5_DLL htri_t             H5T_is_relocatable(const H5T_t *dt);
 H5_DLL H5T_path_t        *H5T_path_find(const H5T_t *src, const H5T_t *dst);
 H5_DLL bool               H5T_path_noop(const H5T_path_t *p);
+H5_DLL bool               H5T_noop_conv(const H5T_t *src, const H5T_t *dst);
 H5_DLL H5T_bkg_t          H5T_path_bkg(const H5T_path_t *p);
 H5_DLL H5T_subset_info_t *H5T_path_compound_subset(const H5T_path_t *p);
 H5_DLL herr_t             H5T_unregister(H5T_pers_t pers, const char *name, H5T_t *src, H5T_t *dst,
