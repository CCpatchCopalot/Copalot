diff --git a/src/H5Defl.c b/src/H5Defl.c
index 05ca107faec..22348e33fcc 100644
--- a/src/H5Defl.c
+++ b/src/H5Defl.c
@@ -137,8 +137,9 @@ H5D__efl_construct(H5F_t *f, H5D_t *dset)
         HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unable to determine datatype size");
 
     /* Check for storage overflows */
-    max_points  = H5S_get_npoints_max(dset->shared->space);
-    max_storage = H5O_efl_total_size(&dset->shared->dcpl_cache.efl);
+    max_points = H5S_get_npoints_max(dset->shared->space);
+    if (H5O_efl_total_size(&dset->shared->dcpl_cache.efl, &max_storage) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve size of external file");
     if (H5S_UNLIMITED == max_points) {
         if (H5O_EFL_UNLIMITED != max_storage)
             HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unlimited dataspace but finite storage");
diff --git a/src/H5Dint.c b/src/H5Dint.c
index 3b9d000f523..71ddda387c7 100644
--- a/src/H5Dint.c
+++ b/src/H5Dint.c
@@ -1789,6 +1789,33 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
         (dataset->shared->layout.type == H5D_VIRTUAL && fill_prop->alloc_time == H5D_ALLOC_TIME_INCR))
         alloc_time_state = 1;
 
+    /* Check if there is a fill value, but no type yet */
+    if (fill_prop->buf != NULL && fill_prop->type == NULL) {
+        H5T_t *tmp_type; /* Temporary pointer to dataset's datatype */
+
+        /* Copy the dataset type into the fill value message */
+        if (NULL == (tmp_type = H5T_copy(dataset->shared->type, H5T_COPY_TRANSIENT)))
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTCOPY, FAIL, "unable to copy dataset datatype for fill value");
+
+        /* Check if conversion is necessary on fill buffer, and if fill-value
+         * buffer is too small to hold the result.
+         */
+        if (!H5T_noop_conv(dataset->shared->type, tmp_type)) {
+            size_t bkg_size = MAX(H5T_GET_SIZE(tmp_type), H5T_GET_SIZE(dataset->shared->type));
+
+            assert(fill_prop->size >= 0);
+            if ((size_t)fill_prop->size < bkg_size) {
+                if (H5T_close_real(tmp_type) < 0)
+                    HDONE_ERROR(H5E_DATASET, H5E_CANTFREE, FAIL, "Can't free temporary datatype");
+                HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL,
+                            "fill value size doesn't match dataset's datatype size");
+            }
+        }
+
+        if (H5T_close_real(tmp_type) < 0)
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTFREE, FAIL, "Can't free temporary datatype");
+    }
+
     /* Set revised fill value properties, if they are different from the defaults */
     if (H5P_fill_value_cmp(&H5D_def_dset.dcpl_cache.fill, fill_prop, sizeof(H5O_fill_t))) {
         if (H5P_set(plist, H5D_CRT_FILL_VALUE_NAME, fill_prop) < 0)
diff --git a/src/H5Gnode.c b/src/H5Gnode.c
index b4bd1214bf8..f211e74e041 100644
--- a/src/H5Gnode.c
+++ b/src/H5Gnode.c
@@ -359,8 +359,14 @@ H5G__node_cmp2(void *_lt_key, void *_udata, void *_rt_key)
     if ((s2 = (const char *)H5HL_offset_into(udata->heap, rt_key->offset)) == NULL)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get key name");
 
+    /* Compute maximum length of string to compare */
+    if (rt_key->offset > lt_key->offset)
+        max_len = udata->block_size - rt_key->offset;
+    else
+        max_len = udata->block_size - lt_key->offset;
+
     /* Set return value */
-    ret_value = strcmp(s1, s2);
+    ret_value = strncmp(s1, s2, max_len);
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
diff --git a/src/H5HG.c b/src/H5HG.c
index 3709c705566..a859b40f100 100644
--- a/src/H5HG.c
+++ b/src/H5HG.c
@@ -556,6 +556,11 @@ H5HG_read(H5F_t *f, H5HG_t *hobj, void *object /*out*/, size_t *buf_size)
     assert(f);
     assert(hobj);
 
+    /* Heap object idx 0 is the free space in the heap and should never be given out */
+    if (0 == hobj->idx)
+        HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, NULL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
+                    hobj->addr, hobj->idx);
+
     /* Load the heap */
     if (NULL == (heap = H5HG__protect(f, hobj->addr, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_HEAP, H5E_CANTPROTECT, NULL, "unable to protect global heap");
diff --git a/src/H5Znbit.c b/src/H5Znbit.c
index fb5c5c51f8d..429394d56c8 100644
--- a/src/H5Znbit.c
+++ b/src/H5Znbit.c
@@ -1180,7 +1180,7 @@ static herr_t
 H5Z__nbit_decompress_one_compound(unsigned char *data, size_t data_offset, unsigned char *buffer, size_t *j,
                                   size_t *buf_len, const unsigned parms[], unsigned *parms_index)
 {
-    unsigned     i, nmembers, member_offset, member_class, member_size, used_size = 0, size;
+    unsigned     i, nmembers, member_offset, member_class, member_size, used_size = 0, prev_used_size, size;
     parms_atomic p;
     herr_t       ret_value = SUCCEED; /* Return value */
 
@@ -1194,10 +1194,15 @@ H5Z__nbit_decompress_one_compound(unsigned char *data, size_t data_offset, unsig
         member_class  = parms[(*parms_index)++];
 
         /* Check for overflow */
-        member_size = parms[*parms_index];
+        member_size    = parms[*parms_index];
+        prev_used_size = used_size;
         used_size += member_size;
         if (used_size > size)
-            HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "compound member offset overflowed compound size");
+            HGOTO_ERROR(H5E_PLINE, H5E_BADVALUE, FAIL, "compound member size overflowed compound size");
+        if (used_size <= prev_used_size)
+            HGOTO_ERROR(H5E_PLINE, H5E_BADVALUE, FAIL, "compound member size overflowed compound size");
+        if ((member_offset + member_size) > size)
+            HGOTO_ERROR(H5E_PLINE, H5E_BADRANGE, FAIL, "compound member offset overflowed compound size");
         switch (member_class) {
             case H5Z_NBIT_ATOMIC:
                 p.size = member_size;