

Yes

```diff
diff --git a/include/str.h b/include/str.h
--- a/include/str.h
+++ b/include/str.h
@@ -137,6 +137,7 @@
 #define PR_STR_FL_PRESERVE_COMMENTS		0x0001
 #define PR_STR_FL_PRESERVE_WHITESPACE		0x0002
 #define PR_STR_FL_IGNORE_CASE			0x0004
+#define PR_STR_FL_IGNORE_QUOTES			0x0008
 
 char *pr_str_get_token(char **, char *);
 char *pr_str_get_token2(char **, char *, size_t *);
diff --git a/src/main.c b/src/main.c
--- a/src/main.c
+++ b/src/main.c
@@ -821,7 +821,21 @@
     return NULL;
   }
 
+  /* By default, pr_str_get_word will handle quotes and backslashes for
+   * escaping characters.  This can produce words which are shorter, use
+   * fewer bytes than the corresponding input buffer.
+   *
+   * In this particular situation, we use the length of this initial word
+   * for determining the length of the remaining buffer bytes, assumed to
+   * contain the FTP command arguments.  If this initial word is thus
+   * unexpectedly "shorter", due to nonconformant FTP text, it can lead
+   * the subsequent buffer scan, looking for CRNUL sequencees, to access
+   * unexpected memory addresses (Issue #1683).
+   *
+   * Thus for this particular situation, we tell the function to ignore/skip
+   * such quote/backslash semantics using the IGNORE_QUOTES flag.
+   */
   ptr = buf;
-  wrd = pr_str_get_word(&ptr, str_flags);
+  wrd = pr_str_get_word(&ptr, str_flags|PR_STR_FL_IGNORE_QUOTES);
   if (wrd == NULL) {
     /* Nothing there...bail out. */
     pr_trace_msg("ctrl", 5, "command '%s' is empty, ignoring", buf);
diff --git a/src/str.c b/src/str.c
--- a/src/str.c
+++ b/src/str.c
@@ -1241,7 +1241,7 @@
 
 char *pr_str_get_word(char **cp, int flags) {
   char *res, *dst;
-  char quote_mode = 0;
+  int quote_mode = FALSE;
 
   if (cp == NULL ||
       !*cp ||
@@ -1270,24 +1270,28 @@
     }
   }
 
-  if (**cp == '\"') {
-    quote_mode++;
-    (*cp)++;
+  if (!(flags & PR_STR_FL_IGNORE_QUOTES)) {
+    if (**cp == '\"') {
+      quote_mode = TRUE;
+      (*cp)++;
+    }
   }
 
   while (**cp && (quote_mode ? (**cp != '\"') : !PR_ISSPACE(**cp))) {
     pr_signals_handle();
 
-    if (**cp == '\\' && quote_mode) {
-
+    if (**cp == '\\' &&
+        quote_mode == TRUE) {
       /* Escaped char */
       if (*((*cp)+1)) {
-        *dst = *(++(*cp));
+        *dst++ = *(++(*cp));
+        (*cp)++;
+        continue;
       }
     }
 
     *dst++ = **cp;
-    ++(*cp);
+    (*cp)++;
   }
 
   if (**cp) {
diff --git a/tests/api/str.c b/tests/api/str.c
--- a/tests/api/str.c
+++ b/tests/api/str.c
@@ -775,6 +775,37 @@
 
   ok = "quz norf";
   ck_assert_msg(strcmp(res, ok) == 0, "Expected '%s', got '%s'", ok, res);
+
+  /* Test embedded quotes with backslashes (Issue #1683). */
+  mark_point();
+
+  str = pstrdup(p, "\"\\\\SYST\"");
+  res = pr_str_get_word(&str, 0);
+  ck_assert_msg(res != NULL, "Failed to handle quoted argument: %s",
+    strerror(errno));
+
+  ok = "\\SYST";
+  ck_assert_msg(strcmp(res, ok) == 0, "Expected '%s', got '%s'", ok, res);
+
+  mark_point();
+  str = pstrdup(p, "\"\"\\\\SYST");
+  res = pr_str_get_word(&str, 0);
+  ck_assert_msg(res != NULL, "Failed to handle quoted argument: %s",
+    strerror(errno));
+
+  ok = "";
+  ck_assert_msg(strcmp(res, ok) == 0, "Expected '%s', got '%s'", ok, res);
+
+  /* Now do the same tests with the IGNORE_QUOTES flag */
+  mark_point();
+
+  str = ok = pstrdup(p, "\"\\\\SYST\"");
+  res = pr_str_get_word(&str, PR_STR_FL_IGNORE_QUOTES);
+  ck_assert_msg(res != NULL, "Failed to handle quoted argument: %s",
+    strerror(errno));
+  ck_assert_msg(strcmp(res, ok) == 0, "Expected '%s', got '%s'", ok, res);
+
+  mark_point();
+  str = ok = pstrdup(p, "\"\"\\\\SYST");
+  res = pr_str_get_word(&str, PR_STR_FL_IGNORE_QUOTES);
+  ck_assert_msg(res != NULL, "Failed to handle quoted argument: %s",
+    strerror(errno));
+  ck_assert_msg(strcmp(res, ok) == 0, "Expected '%s', got '%s'", ok, res);
 }
 END_TEST
```