diff --git a/src/codec/tags/VideoSequence.cpp b/src/codec/tags/VideoSequence.cpp
index 01e92e4ead..4349b19fc0 100644
--- a/src/codec/tags/VideoSequence.cpp
+++ b/src/codec/tags/VideoSequence.cpp
@@ -112,7 +112,7 @@ ByteData* ReadMp4Header(DecodeStream* stream) {
   auto length = stream->readEncodedUint32();
   auto bytes = stream->readBytes(length);
   // must check whether the bytes is valid. otherwise memcpy will crash.
-  if (length == 0 || stream->context->hasException()) {
+  if (length == 0 || length > bytes.length() || stream->context->hasException()) {
     return nullptr;
   }
   auto data = new (std::nothrow) uint8_t[length];
diff --git a/src/codec/utils/DecodeStream.cpp b/src/codec/utils/DecodeStream.cpp
index 082182c655..53ea3b5098 100644
--- a/src/codec/utils/DecodeStream.cpp
+++ b/src/codec/utils/DecodeStream.cpp
@@ -22,7 +22,7 @@
 namespace pag {
 void DecodeStream::setPosition(uint32_t value) {
   if (!checkEndOfFile(value)) {
-    positionChanged(value - _position);
+    positionChanged(static_cast<size_t>(value) - _position);
   }
 }
 
@@ -156,7 +156,7 @@ std::string DecodeStream::readUTF8String() {
     auto maxLength = dataView.size() - _position;
     auto textLength = strnlen(text, maxLength);
     if (textLength < maxLength) {
-      positionChanged(static_cast<off_t>(textLength + 1));
+      positionChanged(textLength + 1);
       return {text, textLength};
     }
   }
@@ -288,17 +288,18 @@ void DecodeStream::readPoint3DList(Point3D* points, uint32_t count, float precis
   }
 }
 
-void DecodeStream::bitPositionChanged(off_t offset) {
+void DecodeStream::bitPositionChanged(size_t offset) {
   _bitPosition += offset;
   _position = BitsToBytes(_bitPosition);
 }
 
-void DecodeStream::positionChanged(off_t offset) {
+void DecodeStream::positionChanged(size_t offset) {
   _position += offset;
-  _bitPosition = static_cast<uint64_t>(_position) * 8;
+  _bitPosition = _position * 8;
 }
 
 bool DecodeStream::checkEndOfFile(uint32_t bytesToRead) {
+  // The _position must not use the uint32_t type, otherwise it will overflow.
   if (_position + bytesToRead > dataView.size()) {
     PAGThrowError(context, "End of file was encountered.");
     return true;
diff --git a/src/codec/utils/DecodeStream.h b/src/codec/utils/DecodeStream.h
index d4e3050b5e..4ecb52c450 100644
--- a/src/codec/utils/DecodeStream.h
+++ b/src/codec/utils/DecodeStream.h
@@ -60,7 +60,7 @@ class DecodeStream final {
    * the end of the stream.
    */
   uint32_t bytesAvailable() const {
-    return static_cast<uint32_t>(dataView.size()) - _position;
+    return static_cast<uint32_t>(dataView.size() - _position);
   }
 
   const uint8_t* data() const {
@@ -79,7 +79,7 @@ class DecodeStream final {
    * is the point at which the next call to a read method starts reading.
    */
   uint32_t position() const {
-    return _position;
+    return static_cast<uint32_t>(_position);
   }
 
   void setPosition(uint32_t value);
@@ -234,12 +234,12 @@ class DecodeStream final {
 
  private:
   tgfx::DataView dataView = {};
-  uint32_t _position = 0;
-  uint64_t _bitPosition = 0;
+  size_t _position = 0;
+  size_t _bitPosition = 0;
 
-  void bitPositionChanged(off_t offset);
+  void bitPositionChanged(size_t offset);
 
-  void positionChanged(off_t offset);
+  void positionChanged(size_t offset);
 
   bool checkEndOfFile(uint32_t bytesToRead);
 };
diff --git a/src/codec/utils/EncodeStream.cpp b/src/codec/utils/EncodeStream.cpp
index a6cab05aff..af50925fe5 100644
--- a/src/codec/utils/EncodeStream.cpp
+++ b/src/codec/utils/EncodeStream.cpp
@@ -127,7 +127,7 @@ void EncodeStream::writeBytes(EncodeStream* stream, uint32_t length, uint32_t of
     return;
   }
   if (length == 0) {
-    length = stream->_length - offset;
+    length = static_cast<uint32_t>(stream->_length) - offset;
   }
   writeBytes(stream->bytes, length, offset);
 }
@@ -149,10 +149,10 @@ void EncodeStream::writeByteData(const pag::ByteData* byteData) {
 }
 
 void EncodeStream::writeUTF8String(const std::string& text) {
-  auto textLength = static_cast<uint32_t>(text.size());
+  auto textLength = text.size();
   if (checkCapacity(textLength + 1)) {
     memcpy(bytes + _position, text.c_str(), textLength + 1);
-    positionChanged(static_cast<off_t>(textLength) + 1);
+    positionChanged(textLength + 1);
   }
 }
 
@@ -307,17 +307,17 @@ void EncodeStream::writePoint3DList(const Point3D* points, uint32_t count, float
   delete[] list;
 }
 
-bool EncodeStream::checkCapacity(uint32_t bytesToWrite) {
+bool EncodeStream::checkCapacity(size_t bytesToWrite) {
   if (_position + bytesToWrite > capacity) {
     return expandCapacity(_position + bytesToWrite);
   }
   return true;
 }
 
-bool EncodeStream::expandCapacity(uint32_t length) {
-  uint32_t newCapacity = capacity == 0 ? 128 : capacity;
+bool EncodeStream::expandCapacity(size_t length) {
+  size_t newCapacity = capacity == 0 ? 128 : capacity;
   while (newCapacity < length) {
-    newCapacity = static_cast<uint32_t>(newCapacity * 1.5);
+    newCapacity = newCapacity / 2 * 3;
   }
   auto newBytes = new (std::nothrow) uint8_t[newCapacity];
   if (newBytes == nullptr) {
@@ -334,7 +334,7 @@ bool EncodeStream::expandCapacity(uint32_t length) {
   return true;
 }
 
-void EncodeStream::bitPositionChanged(off_t offset) {
+void EncodeStream::bitPositionChanged(size_t offset) {
   _bitPosition += offset;
   _position = BitsToBytes(_bitPosition);
   if (_position > _length) {
@@ -342,9 +342,9 @@ void EncodeStream::bitPositionChanged(off_t offset) {
   }
 }
 
-void EncodeStream::positionChanged(off_t offset) {
+void EncodeStream::positionChanged(size_t offset) {
   _position += offset;
-  _bitPosition = static_cast<uint64_t>(_position) * 8;
+  _bitPosition = _position * 8;
   if (_position > _length) {
     _length = _position;
   }
diff --git a/src/codec/utils/EncodeStream.h b/src/codec/utils/EncodeStream.h
index 90a3a9dade..edf09e9e65 100644
--- a/src/codec/utils/EncodeStream.h
+++ b/src/codec/utils/EncodeStream.h
@@ -60,7 +60,7 @@ class EncodeStream final {
    * The length of the EncodeStream object.
    */
   uint32_t length() const {
-    return _length;
+    return static_cast<uint32_t>(_length);
   }
 
   /**
@@ -68,13 +68,13 @@ class EncodeStream final {
    * is the point at which the next call to a write method starts writing.
    */
   uint32_t position() const {
-    return _position;
+    return static_cast<uint32_t>(_position);
   }
 
   void setPosition(uint32_t value);
 
   void alignWithBytes() {
-    _bitPosition = static_cast<uint64_t>(_position) * 8;
+    _bitPosition = _position * 8;
   }
 
   /**
@@ -230,14 +230,14 @@ class EncodeStream final {
  private:
   tgfx::DataView dataView = {};
   uint8_t* bytes = nullptr;
-  uint32_t capacity = 0;
-  uint32_t _length = 0;
-  uint32_t _position = 0;
-  uint64_t _bitPosition = 0;
-
-  bool checkCapacity(uint32_t bytesToWrite);
-  bool expandCapacity(uint32_t length);
-  void bitPositionChanged(off_t offset);
-  void positionChanged(off_t offset);
+  size_t capacity = 0;
+  size_t _length = 0;
+  size_t _position = 0;
+  size_t _bitPosition = 0;
+
+  bool checkCapacity(size_t bytesToWrite);
+  bool expandCapacity(size_t length);
+  void bitPositionChanged(size_t offset);
+  void positionChanged(size_t offset);
 };
 }  // namespace pag
diff --git a/src/codec/utils/NALUReader.cpp b/src/codec/utils/NALUReader.cpp
index 6d39e62b6f..77ef4beef2 100644
--- a/src/codec/utils/NALUReader.cpp
+++ b/src/codec/utils/NALUReader.cpp
@@ -24,7 +24,7 @@ std::unique_ptr<ByteData> ReadByteDataWithStartCode(DecodeStream* stream) {
   auto length = stream->readEncodedUint32();
   auto bytes = stream->readBytes(length);
   // must check whether the bytes is valid. otherwise memcpy will crash.
-  if (length == 0 || stream->context->hasException()) {
+  if (length == 0 || length > bytes.length() || stream->context->hasException()) {
     return nullptr;
   }
   auto data = new (std::nothrow) uint8_t[length + 4];
diff --git a/src/codec/utils/StreamContext.h b/src/codec/utils/StreamContext.h
index ad8980c954..32fea3678f 100644
--- a/src/codec/utils/StreamContext.h
+++ b/src/codec/utils/StreamContext.h
@@ -41,8 +41,8 @@ class StreamContext {
   std::vector<std::string> errorMessages;
 };
 
-inline uint32_t BitsToBytes(uint64_t capacity) {
-  return static_cast<uint32_t>(ceil(capacity * 0.125));
+inline size_t BitsToBytes(size_t capacity) {
+  return static_cast<size_t>(ceil(capacity * 0.125));
 }
 
 #ifdef DEBUG
