diff --git a/picoquic/frames.c b/picoquic/frames.c
index 039d017..cba6a36 100644
--- a/picoquic/frames.c
+++ b/picoquic/frames.c
@@ -501,7 +501,11 @@ protoop_arg_t parse_new_connection_id_frame(picoquic_cnx_t* cnx)
         return (protoop_arg_t) NULL;
     }
 
-    if ((bytes = picoquic_frames_varint_decode(bytes + picoquic_varint_skip(bytes), bytes_max, &frame->sequence)) == NULL ||
+    if (cnx->active_connection_id_count >= cnx->local_parameters.active_connection_id_limit) {
+        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_CONNECTION_ID_LIMIT_ERROR, picoquic_frame_type_new_connection_id);
+        picoquic_reinsert_by_wake_time(cnx->quic, cnx, picoquic_current_time());
+        return (protoop_arg_t) NULL;
+    } else if ((bytes = picoquic_frames_varint_decode(bytes + picoquic_varint_skip(bytes), bytes_max, &frame->sequence)) == NULL ||
         (bytes = picoquic_frames_varint_decode(bytes, bytes_max, &frame->retire_prior_to)) == NULL ||
         (bytes = picoquic_frames_uint8_decode(bytes, bytes_max, &frame->connection_id.id_len)) == NULL ||
         (frame->connection_id.id_len > PICOQUIC_CONNECTION_ID_MAX_SIZE) ||
@@ -520,6 +524,7 @@ protoop_arg_t parse_new_connection_id_frame(picoquic_cnx_t* cnx)
         bytes += frame->connection_id.id_len;
         memcpy(&frame->stateless_reset_token, bytes, 16);
         bytes += 16;
+        cnx->active_connection_id_count++;
     }
 
     protoop_save_outputs(cnx, frame, ack_needed, is_retransmittable);
diff --git a/picoquic/packet.c b/picoquic/packet.c
index cd1fb10..5a45f94 100644
--- a/picoquic/packet.c
+++ b/picoquic/packet.c
@@ -485,11 +485,13 @@ int picoquic_parse_header_and_decrypt(
                 /* Packet is not encrypted */
                 break;
             case picoquic_packet_initial:
-                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,
-                    (*pcnx)->crypto_context[0].hp_dec,
-                    (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);
-                length = ph->offset + ph->payload_length;
-                *consumed = length;
+                if((*pcnx)->crypto_context[0].aead_decrypt != NULL){
+                    decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,
+                        (*pcnx)->crypto_context[0].hp_dec,
+                        (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);
+                    length = ph->offset + ph->payload_length;
+                    *consumed = length;
+                }
                 break;
             case picoquic_packet_retry:
                 /* packet is not encrypted, no sequence number. */
@@ -1345,7 +1347,10 @@ int picoquic_incoming_segment(
                     if (ret == 0) {
                         if (cnx->client_mode == 0) {
                             /* TODO: finish processing initial connection packet */
-                            cnx->local_parameters.original_destination_connection_id = ph.dest_cnx_id;
+                            if(cnx->local_parameters.original_destination_connection_id.id_len == 0){
+                                cnx->local_parameters.original_destination_connection_id = ph.dest_cnx_id;
+                            }
+
                             ret = picoquic_incoming_initial(&cnx, bytes,
                                 addr_from, addr_to, if_index_to, &ph, current_time, *new_context_created);
                         }
@@ -1372,6 +1377,12 @@ int picoquic_incoming_segment(
                 else
                 {
                     ret = picoquic_incoming_client_cleartext(cnx, bytes, &ph, current_time);
+                    
+                    if (ret == 0 && cnx->crypto_context[2].aead_decrypt != NULL && cnx->crypto_context[2].aead_encrypt != NULL)
+                    {
+                        picoquic_implicit_handshake_ack(cnx, cnx->path[0], picoquic_packet_context_initial, current_time);
+                        picoquic_crypto_context_free(&cnx->crypto_context[0]);
+                    }
                 }
                 break;
             case picoquic_packet_0rtt_protected:
diff --git a/picoquic/picoquic_internal.h b/picoquic/picoquic_internal.h
index 5e5ca00..bf1467d 100644
--- a/picoquic/picoquic_internal.h
+++ b/picoquic/picoquic_internal.h
@@ -692,6 +692,7 @@ typedef struct st_picoquic_cnx_t {
     uint64_t offending_frame_type;
     uint32_t retry_token_length;
     uint8_t * retry_token;
+    unsigned int active_connection_id_count;
     unsigned int handshake_done : 1;
     unsigned int handshake_done_sent : 1;
     unsigned int handshake_done_acked : 1;
diff --git a/picoquic/quicctx.c b/picoquic/quicctx.c
index cd4a171..5fda08f 100644
--- a/picoquic/quicctx.c
+++ b/picoquic/quicctx.c
@@ -1352,6 +1352,7 @@ picoquic_cnx_t* picoquic_create_cnx(picoquic_quic_t* quic,
             cnx->cnx_state = picoquic_state_server_init;
             cnx->initial_cnxid = initial_cnx_id;
             cnx->path[0]->remote_cnxid = remote_cnx_id;
+            cnx->active_connection_id_count = 1;
 
             if (quic->cnx_id_callback_fn)
                 quic->cnx_id_callback_fn(cnx->path[0]->local_cnxid, cnx->initial_cnxid,
diff --git a/picoquic/sender.c b/picoquic/sender.c
index 3805b70..cb8e3d4 100644
--- a/picoquic/sender.c
+++ b/picoquic/sender.c
@@ -575,10 +575,12 @@ protoop_arg_t get_checksum_length(picoquic_cnx_t *cnx)
     int is_cleartext_mode = (int) cnx->protoop_inputv[0];
     uint32_t ret = 16;
 
-    if (is_cleartext_mode || cnx->crypto_context[2].aead_encrypt == NULL) {
+    if (is_cleartext_mode && cnx->crypto_context[2].aead_encrypt == NULL && cnx->crypto_context[0].aead_encrypt != NULL) {
         ret = picoquic_aead_get_checksum_length(cnx->crypto_context[0].aead_encrypt);
-    } else {
+    } else if (cnx->crypto_context[2].aead_encrypt != NULL) {
         ret = picoquic_aead_get_checksum_length(cnx->crypto_context[2].aead_encrypt);
+    } else if(cnx->crypto_context[3].aead_encrypt != NULL) {
+        ret = picoquic_aead_get_checksum_length(cnx->crypto_context[3].aead_encrypt);
     }
 
     return (protoop_arg_t) ret;
@@ -608,7 +610,13 @@ uint32_t picoquic_protect_packet(picoquic_cnx_t* cnx,
     uint32_t pn_offset = 0;
     size_t sample_offset = 0;
     uint32_t pn_length = 0;
-    uint32_t aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);
+    uint32_t aead_checksum_length;
+    
+    if(aead_context != NULL){
+        aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);
+    }else{
+        return 0;
+    }
 
     /* Create the packet header just before encrypting the content */
     h_length = picoquic_create_packet_header(cnx, ptype, path_x,
@@ -962,7 +970,7 @@ void picoquic_implicit_handshake_ack(picoquic_cnx_t* cnx, picoquic_path_t *path,
 
     /* Remove packets from the retransmit queue */
     while (p != NULL) {
-        picoquic_packet_t* p_next = p->next_packet;
+        picoquic_packet_t* p_next = p->previous_packet;
         picoquic_path_t * old_path = p->send_path;
 
         /* Update the congestion control state for the path */
@@ -2546,7 +2554,7 @@ int picoquic_prepare_packet_server_init(picoquic_cnx_t* cnx, picoquic_path_t **
 
     /* If context is handshake, verify first that there is no need for retransmit or ack
     * on initial context */
-    if (ret == 0 && pc == picoquic_packet_context_handshake) {
+    if (ret == 0 && pc == picoquic_packet_context_handshake && cnx->crypto_context[0].aead_encrypt != NULL) {
         length = picoquic_prepare_packet_old_context(cnx, picoquic_packet_context_initial,
             path_x, packet, send_buffer_max, current_time, &header_length);
     }
@@ -3171,6 +3179,7 @@ protoop_arg_t schedule_frames_on_path(picoquic_cnx_t *cnx)
                                 length += (uint32_t) data_bytes;
                                 packet->has_handshake_done = 1;
                                 packet->is_pure_ack = 0;
+                                picoquic_crypto_context_free(&cnx->crypto_context[2]);
                             }
                         }
 
