diff --git a/src/insexpand.c b/src/insexpand.c
old mode 100644
new mode 100755
index 37162a48c..f739014d1
--- a/src/insexpand.c
+++ b/src/insexpand.c
@@ -2490,7 +2490,7 @@ ins_compl_next_buf(buf_T *buf, int flag)
 
     if (flag == 'w')		// just windows
     {
-	if (buf == curbuf || wp == NULL)  // first call for this flag/expansion
+	if (buf == curbuf || !win_valid(wp))  // first call for this flag/expansion
 	    wp = curwin;
 	while ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin
 		&& wp->w_buffer->b_scanned)
@@ -3188,7 +3188,8 @@ enum
  */
 typedef struct
 {
-    char_u	*e_cpt;			// current entry in 'complete'
+    char_u	*e_cpt_copy;
+	char_u	*e_cpt;			// current entry in 'complete'
     buf_T	*ins_buf;		// buffer being scanned
     pos_T	*cur_match_pos;			// current match position
     pos_T	prev_match_pos;		// previous match position
@@ -3767,8 +3768,11 @@ ins_compl_get_exp(pos_T *ini)
 	    st.ins_buf->b_scanned = 0;
 	st.found_all = FALSE;
 	st.ins_buf = curbuf;
-	st.e_cpt = (compl_cont_status & CONT_LOCAL)
-					    ? (char_u *)"." : curbuf->b_p_cpt;
+	vim_free(st.e_cpt_copy);
+	// Make a copy of 'complete', if case the buffer is wiped out.
+	st.e_cpt_copy = vim_strsave((compl_cont_status & CONT_LOCAL)
+					    ? (char_u *)"." : curbuf->b_p_cpt);
+	st.e_cpt = st.e_cpt_copy == NULL ? (char_u *)"" : st.e_cpt_copy;
 	st.last_match_pos = st.first_match_pos = *ini;
     }
     else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))
@@ -4112,6 +4116,7 @@ ins_compl_next(
     int	    todo = count;
     int	    advance;
     int	    started = compl_started;
+	buf_T   *orig_curbuf = curbuf;
 
     // When user complete function return -1 for findstart which is next
     // time of 'always', compl_shown_match become NULL.
@@ -4144,6 +4149,14 @@ ins_compl_next(
 							&num_matches) == -1)
 	return -1;
 
+	if (curbuf != orig_curbuf)
+    {
+	// In case some completion function switched buffer, don't want to
+	// insert the completion elsewhere.
+	return -1;
+    }
+
+
     // Insert the text of the new completion, or the compl_leader.
     if (compl_no_insert && !started)
     {
