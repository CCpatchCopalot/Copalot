diff --git a/configure.ac b/configure.ac
index aaeabc00..be461c0a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -252 +252 @@ AC_CHECK_LIB([m],[sqrt])
-AC_CHECK_FUNCS([memchr memmove strcasecmp strchr strrchr strtol strtoul strtoull])
+AC_CHECK_FUNCS([memchr memmove strcasecmp strchr strrchr strtol strtoul strtoull strnlen])
diff --git a/src/bits.c b/src/bits.c
index e1877575..48cfe7c4 100644
--- a/src/bits.c
+++ b/src/bits.c
@@ -1604,0 +1605,40 @@ bit_embed_TU_size (BITCODE_TU restrict wstr, const int len)
+/* len of wide string (unix-only) */
+size_t
+bit_wcs2nlen (BITCODE_TU restrict wstr, const size_t maxlen)
+{
+  size_t len;
+
+  if (!wstr)
+    return 0;
+  len = 0;
+#  ifdef HAVE_ALIGNED_ACCESS_REQUIRED
+  // for strict alignment CPU's like sparc only. also for UBSAN.
+  if ((uintptr_t)wstr % SIZEOF_SIZE_T)
+    {
+      unsigned char *b = (unsigned char *)wstr;
+      uint16_t c = (b[0] << 8) + b[1];
+      while (c)
+        {
+          len++;
+          if (len >= maxlen)
+            return 0;
+          b += 2;
+          c = (b[0] << 8) + b[1];
+        }
+      return len;
+    }
+  else
+#  endif
+  {
+    BITCODE_TU c = wstr;
+    while (*c)
+      {
+        len++;
+        if (len >= maxlen)
+          return 0;
+        c++;
+      }
+    return len;
+  }
+}
+
@@ -1710,0 +1751,21 @@ bit_wcs2cmp (BITCODE_TU restrict dest, const BITCODE_TU restrict src)
+#ifndef HAVE_STRNLEN
+/* bounds-checked len of string */
+size_t
+bit_strnlen (const char *restrict str, const size_t maxlen)
+{
+  size_t len;
+  char *c = str;
+  if (!str)
+    return 0;
+  len = 0;
+  while (*c)
+    {
+      len++;
+      if (len >= maxlen)
+        return 0;
+      c++;
+    }
+  return len;
+}
+#endif
+
diff --git a/src/bits.h b/src/bits.h
index 9f029938..f7e4ce8d 100644
--- a/src/bits.h
+++ b/src/bits.h
@@ -263,0 +264,10 @@ int bit_wcs2cmp (BITCODE_TU restrict s1, const BITCODE_TU restrict s2);
+#ifndef HAVE_STRNLEN
+size_t bit_strnlen (const char *restrict str, const size_t maxlen);
+#define strnlen (str, maxlen) bit_strnlen(str, maxlen)
+#endif
+
+
+/* bounded length of UCS-2 string. stops scanning at maxlen.
+   Beware: might overflow to negative lengths */
+size_t bit_wcs2nlen (BITCODE_TU restrict wstr, const size_t maxlen);
+
diff --git a/src/config.h.in b/src/config.h.in
index c0d4825e..bf3de265 100644
--- a/src/config.h.in
+++ b/src/config.h.in
@@ -158,0 +159,3 @@
+/* Define to 1 if you have the `strnlen' function. */
+#undef HAVE_STRNLEN
+
diff --git a/src/dwg.spec b/src/dwg.spec
index ee4ffc21..83310f52 100644
--- a/src/dwg.spec
+++ b/src/dwg.spec
@@ -3000 +3000,6 @@ DWG_OBJECT (LTYPE)
-                static int dash_i = 0;
+                static unsigned int dash_i = 0;
+                if (dash_i >= 256)
+                  {
+                    LOG_ERROR ("dashes[%u] overflow @%u", rcount1, dash_i)
+                    break;
+                  }
@@ -3002 +3007,2 @@ DWG_OBJECT (LTYPE)
-                dash_i += strlen (_obj->dashes[rcount1].text) + 1;
+                LOG_TRACE ("dashes[%u] @%u\n", rcount1, dash_i)
+                dash_i += strnlen (_obj->dashes[rcount1].text, 256 - dash_i) + 1;
@@ -3016,0 +3023,2 @@ DWG_OBJECT (LTYPE)
+                if (dash_i >= 512)
+                  break;
@@ -3018 +3026 @@ DWG_OBJECT (LTYPE)
-                dash_i += bit_wcs2len ((BITCODE_TU)_obj->dashes[rcount1].text) + 2;
+                dash_i += (2 * bit_wcs2nlen ((BITCODE_TU)_obj->dashes[rcount1].text, 256 - (dash_i / 2))) + 2;
diff --git a/src/free.c b/src/free.c
index 7d5e210b..e33ee488 100644
--- a/src/free.c
+++ b/src/free.c
@@ -1168,2 +1167,0 @@ dwg_free_header_vars (Dwg_Data *dwg)
-  if (dwg->opts & DWG_OPTS_MINIMAL)
-    FREE_IF (_obj->HANDSEED);
