diff --git a/src/http_server/api/v1/trace.c b/src/http_server/api/v1/trace.c
index 95da17343..36a5994bf 100644
--- a/src/http_server/api/v1/trace.c
+++ b/src/http_server/api/v1/trace.c
@@ -39,7 +39,10 @@ static struct flb_input_instance *find_input(struct flb_hs *hs, const char *name
 
     mk_list_foreach(head, &hs->config->inputs) {
         in = mk_list_entry(head, struct flb_input_instance, _head);
-        if (strcmp(name, in->name) == 0) {
+        if (strlen(in->name) != nlen) {
+                continue;
+            }
+        if (strncmp(name, in->name, nlen) == 0) {
             return in;
         }
         if (in->alias) {
@@ -89,12 +92,12 @@ static flb_sds_t get_input_name(mk_request_t *request)
     if (request->real_path.data == NULL) {
         return NULL;
     }
-    if (request->real_path.len < strlen(base)) {
+    if (request->real_path.len < sizeof(base)-1) {
         return NULL;
     }
 
-    return flb_sds_create_len(&request->real_path.data[strlen(base)],
-                              request->real_path.len - strlen(base));
+    return flb_sds_create_len(&request->real_path.data[sizeof(base)-1],
+                                request->real_path.len - sizeof(base)-1);
 }
 
 static int http_disable_trace(mk_request_t *request, void *data, const char *input_name, msgpack_packer *mp_pck)
@@ -524,13 +527,11 @@ static void cb_traces(mk_request_t *request, void *data)
     msgpack_pack_map(&mp_pck, inputs->size);
 
     for (i = 0; i < inputs->size; i++) {
-        input_name = flb_sds_create_len(inputs->ptr[i].via.str.ptr, inputs->ptr[i].via.str.size);
-        msgpack_pack_str_with_body(&mp_pck, input_name, flb_sds_len(input_name));
-
-        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR) {
-            msgpack_pack_map(&mp_pck, 1);
-            msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
-            msgpack_pack_str_with_body(&mp_pck, "error", strlen("error"));
+        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR || inputs->ptr[i].via.str.ptr == NULL) {
+                response = 503;
+                error_msg = flb_sds_create("invalid input");
+                msgpack_sbuffer_clear(&mp_sbuf);
+                goto unpack_error;
         }
         else {
             if (request->method == MK_METHOD_POST || request->method == MK_METHOD_GET) {
@@ -551,15 +552,47 @@ static void cb_traces(mk_request_t *request, void *data)
             else if (request->method == MK_METHOD_DELETE) {
                 disable_trace_input((struct flb_hs *)data, input_name);
             }
+            for (i = 0; i < inputs->size; i++) {
+
+                input_name = inputs->ptr[i].via.str.ptr;
+                input_nlen = inputs->ptr[i].via.str.size;
+
+                msgpack_pack_str_with_body(&mp_pck, input_name, input_nlen);
+
+                if (request->method == MK_METHOD_POST) {
+
+                    ret = msgpack_params_enable_trace((struct flb_hs *)data, &result,
+                                                      input_name, input_nlen);
+
+                    if (ret != 0) {
+                        msgpack_pack_map(&mp_pck, 2);
+                        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);
+                        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);
+                        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_RETURNCODE,
+                                                   HTTP_FIELD_RETURNCODE_LEN);
+                        msgpack_pack_int64(&mp_pck, ret);
+                             }
             else {
-                msgpack_pack_map(&mp_pck, 2);
-                msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
-                msgpack_pack_str_with_body(&mp_pck, "error", strlen("error"));
-                msgpack_pack_str_with_body(&mp_pck, "message", strlen("message"));
-                msgpack_pack_str_with_body(&mp_pck, "method not allowed", strlen("method not allowed"));
-            }
-        }
-    }
+                msgpack_pack_map(&mp_pck, 1);
+msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);
+msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);
+             }
+         }
+else if (request->method == MK_METHOD_DELETE) {
+    disable_trace_input((struct flb_hs *)data, input_name, input_nlen);
+    msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);
+    msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);
+}
+else {
+    msgpack_pack_map(&mp_pck, 2);
+    msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);
+    msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);
+    msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);
+    msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_METHODNOTALLOWED,
+                       HTTP_RESULT_METHODNOTALLOWED_LEN);
+}
+     }
+ 
 
     msgpack_pack_str_with_body(&mp_pck, "result", strlen("result"));
 unpack_error:
