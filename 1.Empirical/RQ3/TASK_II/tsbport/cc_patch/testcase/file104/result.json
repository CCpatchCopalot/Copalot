{
    "testcase": {
        "file104": {
            "match_message": {
                "Syntax: ossl_check_cxn -> ossl_connect_step1": {
                    "Seg_0": {
                        "Edit": "add",
                        "L1": "7: Context line (Ignored) is empty or comment 2238",
                        "L2": "6: Matched by Text Context Similarity from Source Code 2239->2468"
                    },
                    "Seg_1": {
                        "Edit": "delete",
                        "L1": "3: Unique Matched by Source code 2765 -> 3147",
                        "L2": "6: Matched by Text Context Similarity from Source Code 2781->3130 ([[3130, 0.4787234042553191], [3186, 0.448512585812357], [3139, 0.4015594541910331], [3126, 0.3970588235294118], [2712, 0.3932853717026379], [2701, 0.3925729442970822], [2530, 0.3924731182795699], [2543, 0.3924731182795699], [2565, 0.39037433155080214], [2474, 0.383495145631068], [2686, 0.38095238095238093], [2794, 0.3786407766990292], [2519, 0.37823834196891193], [2467, 0.3645569620253165], [2733, 0.3626373626373627], [2667, 0.3549295774647887], [3144, 0.3549060542797495], [2649, 0.3545706371191135], [2473, 0.3502824858757062], [3076, 0.3398058252427184], [2547, 0.33924050632911396], [3091, 0.3387755102040816], [2573, 0.3207547169811321], [3062, 0.32061068702290074], [2534, 0.31421446384039897], [2854, 0.3125], [3032, 0.31196581196581197], [2624, 0.3090507726269316], [2948, 0.3073684210526316], [2619, 0.30028328611898014], [2819, 0.30000000000000004], [2484, 0.2992424242424242], [2615, 0.2985915492957747], [2866, 0.297071129707113], [2480, 0.29574861367837335], [2631, 0.2785862785862786], [2789, 0.2782152230971129], [2966, 0.27685950413223137], [3024, 0.26987951807228916], [2721, 0.26980728051391867]])"
                    },
                    "Seg_2": {
                        "Edit": "add",
                        "L1": "6: Matched by Text Context Similarity from Source Code 2783->3160",
                        "L2": "6: Matched by Text Context Similarity from Source Code 2784->3160"
                    },
                    "Seg_4": {
                        "Edit": "change",
                        "L1": "6: Matched by Text Context Similarity from Source Code 2792->3166",
                        "L2": "6: Matched by Text Context Similarity from Source Code 2792->3166"
                    },
                    "Seg_5": {
                        "Edit": "delete",
                        "L1": "6: Matched by Text Context Similarity from Source Code 2795->3171",
                        "L2": "3: Unique Matched by Source code 2800 -> 3176"
                    },
                    "Seg_6": {
                        "Edit": "add",
                        "L1": "3: Unique Matched by Source code 2801 -> 3177",
                        "L2": "3: Unique Matched by Source code 2802 -> 3178"
                    }
                },
                "Coarse:[Pa_Macro_Definition]||[Pc_Macro_Definition]": {
                    "Seg_7": {
                        "Edit": "add",
                        "L1": "3873 -> 4420",
                        "L2": "3874 -> 4421",
                        "debug": {
                            "runtime info": "True,{'state': 'success', 'type': 'src:function', 'info': ['precise context mattch']}",
                            "verify location": "-1",
                            "output location": "4420",
                            "verify result": "False"
                        },
                        "type": "src:function",
                        "raw_match_info": {
                            "state": "success",
                            "type": "src:function",
                            "info": [
                                "precise context mattch"
                            ]
                        }
                    },
                    "Seg_8": {
                        "Edit": "change",
                        "L1": "3879 -> 4425",
                        "L2": "3909 -> 4455",
                        "debug": {
                            "runtime info": "True,{'state': 'success', 'type': 'unknown', 'info': ['precise context mattch']}",
                            "verify location": "-1",
                            "output location": "4425",
                            "verify result": "False"
                        },
                        "type": "unknown",
                        "raw_match_info": {
                            "state": "success",
                            "type": "unknown",
                            "info": [
                                "precise context mattch"
                            ]
                        }
                    },
                    "Seg_9": {
                        "Edit": "add",
                        "L1": "3910 -> -1",
                        "L2": "3911 -> -1",
                        "debug": {
                            "runtime info": "True,{'state': 'default', 'type': 'unknown', 'info': ['unknown out block']}",
                            "verify location": "-1",
                            "output location": "-1",
                            "verify result": "True"
                        },
                        "type": "unknown",
                        "raw_match_info": {
                            "state": "default",
                            "type": "unknown",
                            "info": [
                                "unknown out block"
                            ]
                        }
                    },
                    "Seg_10": {
                        "Edit": "add",
                        "L1": "3911 -> 4457",
                        "L2": "3912 -> 4458",
                        "debug": {
                            "runtime info": "True,{'state': 'success', 'type': 'unknown', 'info': ['precise context mattch']}",
                            "verify location": "-1",
                            "output location": "4457",
                            "verify result": "False"
                        },
                        "type": "unknown",
                        "raw_match_info": {
                            "state": "success",
                            "type": "unknown",
                            "info": [
                                "precise context mattch"
                            ]
                        }
                    }
                }
            },
            "verify_message": {},
            "prepare_info": [
                [
                    "Seg_9",
                    {
                        "Edit": "add",
                        "add_location": -1,
                        "add_hunk": [
                            "  ossl_sha256sum,           /* sha256sum */\n"
                        ]
                    }
                ],
                [
                    "Seg_1",
                    {
                        "Edit": "delete",
                        "delete_location": [
                            2465,
                            3186
                        ],
                        "delete_hunk": [
                            "#else\n",
                            "  const char * const hostname = conn->host.name;\n",
                            "#endif\n",
                            "#ifdef ENABLE_IPV6\n",
                            "  struct in6_addr addr;\n",
                            "#else\n",
                            "  struct in_addr addr;\n",
                            "#endif\n",
                            "#endif\n",
                            "#ifndef CURL_DISABLE_PROXY\n",
                            "  long * const certverifyresult = SSL_IS_PROXY() ?\n",
                            "    &data->set.proxy_ssl.certverifyresult : &data->set.ssl.certverifyresult;\n",
                            "#else\n",
                            "  long * const certverifyresult = &data->set.ssl.certverifyresult;\n",
                            "#endif\n",
                            "  const long int ssl_version = SSL_CONN_CONFIG(version);\n",
                            "#ifdef USE_TLS_SRP\n",
                            "  const enum CURL_TLSAUTH ssl_authtype = SSL_SET_OPTION(authtype);\n",
                            "#endif\n",
                            "  char * const ssl_cert = SSL_SET_OPTION(cert);\n",
                            "  const struct curl_blob *ssl_cert_blob = SSL_SET_OPTION(cert_blob);\n",
                            "  const char * const ssl_cert_type = SSL_SET_OPTION(cert_type);\n",
                            "  const char * const ssl_cafile = SSL_CONN_CONFIG(CAfile);\n",
                            "  const char * const ssl_capath = SSL_CONN_CONFIG(CApath);\n",
                            "  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n",
                            "  const char * const ssl_crlfile = SSL_SET_OPTION(CRLfile);\n",
                            "  char error_buffer[256];\n",
                            "  struct ssl_backend_data *backend = connssl->backend;\n",
                            "  bool imported_native_ca = false;\n",
                            "  DEBUGASSERT(ssl_connect_1 == connssl->connecting_state);\n",
                            "  result = Curl_ossl_seed(data);\n",
                            "  if(result)\n",
                            "    return result;\n",
                            "  *certverifyresult = !X509_V_OK;\n",
                            "  switch(ssl_version) {\n",
                            "  case CURL_SSLVERSION_DEFAULT:\n",
                            "  case CURL_SSLVERSION_TLSv1:\n",
                            "  case CURL_SSLVERSION_TLSv1_0:\n",
                            "  case CURL_SSLVERSION_TLSv1_1:\n",
                            "  case CURL_SSLVERSION_TLSv1_2:\n",
                            "  case CURL_SSLVERSION_TLSv1_3:\n",
                            "#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)\n",
                            "    req_method = TLS_client_method();\n",
                            "#else\n",
                            "    req_method = SSLv23_client_method();\n",
                            "#endif\n",
                            "    use_sni(TRUE);\n",
                            "    break;\n",
                            "  case CURL_SSLVERSION_SSLv2:\n",
                            "#ifdef OPENSSL_NO_SSL2\n",
                            "    failf(data, OSSL_PACKAGE \" was built without SSLv2 support\");\n",
                            "    return CURLE_NOT_BUILT_IN;\n",
                            "#else\n",
                            "#ifdef USE_TLS_SRP\n",
                            "    if(ssl_authtype == CURL_TLSAUTH_SRP)\n",
                            "      return CURLE_SSL_CONNECT_ERROR;\n",
                            "#endif\n",
                            "    req_method = SSLv2_client_method();\n",
                            "    use_sni(FALSE);\n",
                            "    break;\n",
                            "#endif\n",
                            "  case CURL_SSLVERSION_SSLv3:\n",
                            "#ifdef OPENSSL_NO_SSL3_METHOD\n",
                            "    failf(data, OSSL_PACKAGE \" was built without SSLv3 support\");\n",
                            "    return CURLE_NOT_BUILT_IN;\n",
                            "#else\n",
                            "#ifdef USE_TLS_SRP\n",
                            "    if(ssl_authtype == CURL_TLSAUTH_SRP)\n",
                            "      return CURLE_SSL_CONNECT_ERROR;\n",
                            "#endif\n",
                            "    req_method = SSLv3_client_method();\n",
                            "    use_sni(FALSE);\n",
                            "    break;\n",
                            "#endif\n",
                            "  default:\n",
                            "    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n",
                            "    return CURLE_SSL_CONNECT_ERROR;\n",
                            "  }\n",
                            "  if(backend->ctx)\n",
                            "    SSL_CTX_free(backend->ctx);\n",
                            "  backend->ctx = SSL_CTX_new(req_method);\n",
                            "  if(!backend->ctx) {\n",
                            "    failf(data, \"SSL: couldn't create a context: %s\",\n",
                            "          ossl_strerror(ERR_peek_error(), error_buffer, sizeof(error_buffer)));\n",
                            "    return CURLE_OUT_OF_MEMORY;\n",
                            "  }\n",
                            "#ifdef SSL_MODE_RELEASE_BUFFERS\n",
                            "  SSL_CTX_set_mode(backend->ctx, SSL_MODE_RELEASE_BUFFERS);\n",
                            "#endif\n",
                            "#ifdef SSL_CTRL_SET_MSG_CALLBACK\n",
                            "  if(data->set.fdebug && data->set.verbose) {\n",
                            "    SSL_CTX_set_msg_callback(backend->ctx, ssl_tls_trace);\n",
                            "    SSL_CTX_set_msg_callback_arg(backend->ctx, conn);\n",
                            "  }\n",
                            "#endif\n",
                            "  ctx_options = SSL_OP_ALL;\n",
                            "#ifdef SSL_OP_NO_TICKET\n",
                            "  ctx_options |= SSL_OP_NO_TICKET;\n",
                            "#endif\n",
                            "#ifdef SSL_OP_NO_COMPRESSION\n",
                            "  ctx_options |= SSL_OP_NO_COMPRESSION;\n",
                            "#endif\n",
                            "#ifdef SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG\n",
                            "  ctx_options &= ~SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;\n",
                            "#endif\n",
                            "#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\n",
                            "  if(!SSL_SET_OPTION(enable_beast))\n",
                            "    ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\n",
                            "#endif\n",
                            "  switch(ssl_version) {\n",
                            "    case CURL_SSLVERSION_SSLv2:\n",
                            "#if OPENSSL_VERSION_NUMBER >= 0x10100000L /* 1.1.0 */\n",
                            "      SSL_CTX_set_min_proto_version(backend->ctx, SSL2_VERSION);\n",
                            "      SSL_CTX_set_max_proto_version(backend->ctx, SSL2_VERSION);\n",
                            "#else\n",
                            "      ctx_options |= SSL_OP_NO_SSLv3;\n",
                            "      ctx_options |= SSL_OP_NO_TLSv1;\n",
                            "#  if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n",
                            "      ctx_options |= SSL_OP_NO_TLSv1_1;\n",
                            "      ctx_options |= SSL_OP_NO_TLSv1_2;\n",
                            "#    ifdef TLS1_3_VERSION\n",
                            "      ctx_options |= SSL_OP_NO_TLSv1_3;\n",
                            "#    endif\n",
                            "#  endif\n",
                            "#endif\n",
                            "      break;\n",
                            "    case CURL_SSLVERSION_SSLv3:\n",
                            "#if OPENSSL_VERSION_NUMBER >= 0x10100000L /* 1.1.0 */\n",
                            "      SSL_CTX_set_min_proto_version(backend->ctx, SSL3_VERSION);\n",
                            "      SSL_CTX_set_max_proto_version(backend->ctx, SSL3_VERSION);\n",
                            "#else\n",
                            "      ctx_options |= SSL_OP_NO_SSLv2;\n",
                            "      ctx_options |= SSL_OP_NO_TLSv1;\n",
                            "#  if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n",
                            "      ctx_options |= SSL_OP_NO_TLSv1_1;\n",
                            "      ctx_options |= SSL_OP_NO_TLSv1_2;\n",
                            "#    ifdef TLS1_3_VERSION\n",
                            "      ctx_options |= SSL_OP_NO_TLSv1_3;\n",
                            "#    endif\n",
                            "#  endif\n",
                            "#endif\n",
                            "      break;\n",
                            "    case CURL_SSLVERSION_DEFAULT:\n",
                            "    case CURL_SSLVERSION_TLSv1: /* TLS >= version 1.0 */\n",
                            "    case CURL_SSLVERSION_TLSv1_0: /* TLS >= version 1.0 */\n",
                            "    case CURL_SSLVERSION_TLSv1_1: /* TLS >= version 1.1 */\n",
                            "    case CURL_SSLVERSION_TLSv1_2: /* TLS >= version 1.2 */\n",
                            "    case CURL_SSLVERSION_TLSv1_3: /* TLS >= version 1.3 */\n",
                            "      ctx_options |= SSL_OP_NO_SSLv2;\n",
                            "      ctx_options |= SSL_OP_NO_SSLv3;\n",
                            "#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) /* 1.1.0 */\n",
                            "      result = set_ssl_version_min_max(backend->ctx, conn);\n",
                            "#else\n",
                            "      result = set_ssl_version_min_max_legacy(&ctx_options, conn, sockindex);\n",
                            "#endif\n",
                            "      if(result != CURLE_OK)\n",
                            "        return result;\n",
                            "      break;\n",
                            "    default:\n",
                            "      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n",
                            "      return CURLE_SSL_CONNECT_ERROR;\n",
                            "  }\n",
                            "  SSL_CTX_set_options(backend->ctx, ctx_options);\n",
                            "#ifdef HAS_NPN\n",
                            "  if(conn->bits.tls_enable_npn)\n",
                            "    SSL_CTX_set_next_proto_select_cb(backend->ctx, select_next_proto_cb, conn);\n",
                            "#endif\n",
                            "#ifdef HAS_ALPN\n",
                            "  if(conn->bits.tls_enable_alpn) {\n",
                            "    int cur = 0;\n",
                            "    unsigned char protocols[128];\n",
                            "#ifdef USE_NGHTTP2\n",
                            "    if(data->set.httpversion >= CURL_HTTP_VERSION_2\n",
                            "#ifndef CURL_DISABLE_PROXY\n",
                            "       && (!SSL_IS_PROXY() || !conn->bits.tunnel_proxy)\n",
                            "#endif\n",
                            "      ) {\n",
                            "      protocols[cur++] = NGHTTP2_PROTO_VERSION_ID_LEN;\n",
                            "      memcpy(&protocols[cur], NGHTTP2_PROTO_VERSION_ID,\n",
                            "          NGHTTP2_PROTO_VERSION_ID_LEN);\n",
                            "      cur += NGHTTP2_PROTO_VERSION_ID_LEN;\n",
                            "      infof(data, \"ALPN, offering %s\\n\", NGHTTP2_PROTO_VERSION_ID);\n",
                            "    }\n",
                            "#endif\n",
                            "    protocols[cur++] = ALPN_HTTP_1_1_LENGTH;\n",
                            "    memcpy(&protocols[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n",
                            "    cur += ALPN_HTTP_1_1_LENGTH;\n",
                            "    infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n",
                            "    SSL_CTX_set_alpn_protos(backend->ctx, protocols, cur);\n",
                            "  }\n",
                            "#endif\n",
                            "  if(ssl_cert || ssl_cert_blob || ssl_cert_type) {\n",
                            "    BIO *ssl_cert_bio = NULL;\n",
                            "    BIO *ssl_key_bio = NULL;\n",
                            "    int result_cert_stuff;\n",
                            "    if(ssl_cert_blob) {\n",
                            "      ssl_cert_bio = BIO_new_mem_buf(ssl_cert_blob->data,\n",
                            "                                     (int)ssl_cert_blob->len);\n",
                            "      if(!ssl_cert_bio)\n",
                            "        return CURLE_SSL_CERTPROBLEM;\n",
                            "    }\n",
                            "    if(SSL_SET_OPTION(key_blob)) {\n",
                            "      ssl_key_bio = BIO_new_mem_buf(SSL_SET_OPTION(key_blob)->data,\n",
                            "                                    (int)SSL_SET_OPTION(key_blob)->len);\n",
                            "      if(!ssl_key_bio)\n",
                            "        return CURLE_SSL_CERTPROBLEM;\n",
                            "    }\n",
                            "    result_cert_stuff = cert_stuff(conn, backend->ctx,\n",
                            "                   ssl_cert, ssl_cert_bio, ssl_cert_type,\n",
                            "                   SSL_SET_OPTION(key), ssl_key_bio,\n",
                            "                   SSL_SET_OPTION(key_type), SSL_SET_OPTION(key_passwd));\n",
                            "    if(ssl_cert_bio)\n",
                            "      BIO_free(ssl_cert_bio);\n",
                            "    if(ssl_key_bio)\n",
                            "      BIO_free(ssl_key_bio);\n",
                            "    if(!result_cert_stuff) {\n",
                            "      return CURLE_SSL_CERTPROBLEM;\n",
                            "    }\n",
                            "  }\n",
                            "  ciphers = SSL_CONN_CONFIG(cipher_list);\n",
                            "  if(!ciphers)\n",
                            "    ciphers = (char *)DEFAULT_CIPHER_SELECTION;\n",
                            "  if(ciphers) {\n",
                            "    if(!SSL_CTX_set_cipher_list(backend->ctx, ciphers)) {\n",
                            "      failf(data, \"failed setting cipher list: %s\", ciphers);\n",
                            "      return CURLE_SSL_CIPHER;\n",
                            "    }\n",
                            "    infof(data, \"Cipher selection: %s\\n\", ciphers);\n",
                            "  }\n",
                            "#ifdef HAVE_SSL_CTX_SET_CIPHERSUITES\n",
                            "  {\n",
                            "    char *ciphers13 = SSL_CONN_CONFIG(cipher_list13);\n",
                            "    if(ciphers13) {\n",
                            "      if(!SSL_CTX_set_ciphersuites(backend->ctx, ciphers13)) {\n",
                            "        failf(data, \"failed setting TLS 1.3 cipher suite: %s\", ciphers13);\n",
                            "        return CURLE_SSL_CIPHER;\n",
                            "      }\n",
                            "      infof(data, \"TLS 1.3 cipher selection: %s\\n\", ciphers13);\n",
                            "    }\n",
                            "  }\n",
                            "#endif\n",
                            "#ifdef HAVE_SSL_CTX_SET_POST_HANDSHAKE_AUTH\n",
                            "  SSL_CTX_set_post_handshake_auth(backend->ctx, 1);\n",
                            "#endif\n",
                            "#ifdef USE_TLS_SRP\n",
                            "  if(ssl_authtype == CURL_TLSAUTH_SRP) {\n",
                            "    char * const ssl_username = SSL_SET_OPTION(username);\n",
                            "    infof(data, \"Using TLS-SRP username: %s\\n\", ssl_username);\n",
                            "    if(!SSL_CTX_set_srp_username(backend->ctx, ssl_username)) {\n",
                            "      failf(data, \"Unable to set SRP user name\");\n",
                            "      return CURLE_BAD_FUNCTION_ARGUMENT;\n",
                            "    }\n",
                            "    if(!SSL_CTX_set_srp_password(backend->ctx, SSL_SET_OPTION(password))) {\n",
                            "      failf(data, \"failed setting SRP password\");\n",
                            "      return CURLE_BAD_FUNCTION_ARGUMENT;\n",
                            "    }\n",
                            "    if(!SSL_CONN_CONFIG(cipher_list)) {\n",
                            "      infof(data, \"Setting cipher list SRP\\n\");\n",
                            "      if(!SSL_CTX_set_cipher_list(backend->ctx, \"SRP\")) {\n",
                            "        failf(data, \"failed setting SRP cipher list\");\n",
                            "        return CURLE_SSL_CIPHER;\n",
                            "      }\n",
                            "    }\n",
                            "  }\n",
                            "#endif\n",
                            "#if defined(USE_WIN32_CRYPTO)\n",
                            "  if((SSL_CONN_CONFIG(verifypeer) || SSL_CONN_CONFIG(verifyhost)) &&\n",
                            "     (SSL_SET_OPTION(native_ca_store))) {\n",
                            "    X509_STORE *store = SSL_CTX_get_cert_store(backend->ctx);\n",
                            "    HCERTSTORE hStore = CertOpenSystemStore((HCRYPTPROV_LEGACY)NULL,\n",
                            "                                            TEXT(\"ROOT\"));\n",
                            "    if(hStore) {\n",
                            "      PCCERT_CONTEXT pContext = NULL;\n",
                            "      CERT_ENHKEY_USAGE *enhkey_usage = NULL;\n",
                            "      DWORD enhkey_usage_size = 0;\n",
                            "      result = CURLE_OK;\n",
                            "      for(;;) {\n",
                            "        X509 *x509;\n",
                            "        FILETIME now;\n",
                            "        BYTE key_usage[2];\n",
                            "        DWORD req_size;\n",
                            "        const unsigned char *encoded_cert;\n",
                            "#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n",
                            "        char cert_name[256];\n",
                            "#endif\n",
                            "        pContext = CertEnumCertificatesInStore(hStore, pContext);\n",
                            "        if(!pContext)\n",
                            "          break;\n",
                            "#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n",
                            "        if(!CertGetNameStringA(pContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0,\n",
                            "                               NULL, cert_name, sizeof(cert_name))) {\n",
                            "          strcpy(cert_name, \"Unknown\");\n",
                            "        }\n",
                            "        infof(data, \"SSL: Checking cert \\\"%s\\\"\\n\", cert_name);\n",
                            "#endif\n",
                            "        encoded_cert = (const unsigned char *)pContext->pbCertEncoded;\n",
                            "        if(!encoded_cert)\n",
                            "          continue;\n",
                            "        GetSystemTimeAsFileTime(&now);\n",
                            "        if(CompareFileTime(&pContext->pCertInfo->NotBefore, &now) > 0 ||\n",
                            "           CompareFileTime(&now, &pContext->pCertInfo->NotAfter) > 0)\n",
                            "          continue;\n",
                            "        if(CertGetIntendedKeyUsage(pContext->dwCertEncodingType,\n",
                            "                                   pContext->pCertInfo,\n",
                            "                                   key_usage, sizeof(key_usage))) {\n",
                            "          if(!(key_usage[0] & CERT_KEY_CERT_SIGN_KEY_USAGE))\n",
                            "            continue;\n",
                            "        }\n",
                            "        else if(GetLastError())\n",
                            "          continue;\n",
                            "        if(CertGetEnhancedKeyUsage(pContext, 0, NULL, &req_size)) {\n",
                            "          if(req_size && req_size > enhkey_usage_size) {\n",
                            "            void *tmp = realloc(enhkey_usage, req_size);\n",
                            "            if(!tmp) {\n",
                            "              failf(data, \"SSL: Out of memory allocating for OID list\");\n",
                            "              result = CURLE_OUT_OF_MEMORY;\n",
                            "              break;\n",
                            "            }\n",
                            "            enhkey_usage = (CERT_ENHKEY_USAGE *)tmp;\n",
                            "            enhkey_usage_size = req_size;\n",
                            "          }\n",
                            "          if(CertGetEnhancedKeyUsage(pContext, 0, enhkey_usage, &req_size)) {\n",
                            "            if(!enhkey_usage->cUsageIdentifier) {\n",
                            "              if(GetLastError() != CRYPT_E_NOT_FOUND)\n",
                            "                continue;\n",
                            "            }\n",
                            "            else {\n",
                            "              DWORD i;\n",
                            "              bool found = false;\n",
                            "              for(i = 0; i < enhkey_usage->cUsageIdentifier; ++i) {\n",
                            "                if(!strcmp(\"1.3.6.1.5.5.7.3.1\" /* OID server auth */,\n",
                            "                           enhkey_usage->rgpszUsageIdentifier[i])) {\n",
                            "                  found = true;\n",
                            "                  break;\n",
                            "                }\n",
                            "              }\n",
                            "              if(!found)\n",
                            "                continue;\n",
                            "            }\n",
                            "          }\n",
                            "          else\n",
                            "            continue;\n",
                            "        }\n",
                            "        else\n",
                            "          continue;\n",
                            "        x509 = d2i_X509(NULL, &encoded_cert, pContext->cbCertEncoded);\n",
                            "        if(!x509)\n",
                            "          continue;\n",
                            "        if(X509_STORE_add_cert(store, x509) == 1) {\n",
                            "#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n",
                            "          infof(data, \"SSL: Imported cert \\\"%s\\\"\\n\", cert_name);\n",
                            "#endif\n",
                            "          imported_native_ca = true;\n",
                            "        }\n",
                            "        X509_free(x509);\n",
                            "      }\n",
                            "      free(enhkey_usage);\n",
                            "      CertFreeCertificateContext(pContext);\n",
                            "      CertCloseStore(hStore, 0);\n",
                            "      if(result)\n",
                            "        return result;\n",
                            "    }\n",
                            "    if(imported_native_ca)\n",
                            "      infof(data, \"successfully imported windows ca store\\n\");\n",
                            "    else\n",
                            "      infof(data, \"error importing windows ca store, continuing anyway\\n\");\n",
                            "  }\n",
                            "#endif\n",
                            "#if defined(OPENSSL_VERSION_MAJOR) && (OPENSSL_VERSION_MAJOR >= 3)\n",
                            "  {\n",
                            "    if(ssl_cafile) {\n",
                            "      if(!SSL_CTX_load_verify_file(backend->ctx, ssl_cafile)) {\n",
                            "        if(verifypeer) {\n",
                            "          failf(data, \"error setting certificate file: %s\", ssl_cafile);\n",
                            "          return CURLE_SSL_CACERT_BADFILE;\n",
                            "        }\n",
                            "        infof(data, \"error setting certificate file, continuing anyway\\n\");\n",
                            "      }\n",
                            "      infof(data, \"  CAfile: %s\\n\", ssl_cafile);\n",
                            "    }\n",
                            "    if(ssl_capath) {\n",
                            "      if(!SSL_CTX_load_verify_dir(backend->ctx, ssl_capath)) {\n",
                            "        if(verifypeer) {\n",
                            "          failf(data, \"error setting certificate path: %s\", ssl_capath);\n",
                            "          return CURLE_SSL_CACERT_BADFILE;\n",
                            "        }\n",
                            "        infof(data, \"error setting certificate path, continuing anyway\\n\");\n",
                            "      }\n",
                            "      infof(data, \"  CApath: %s\\n\", ssl_capath);\n",
                            "    }\n",
                            "  }\n",
                            "#else\n",
                            "  if(ssl_cafile || ssl_capath) {\n",
                            "    if(!SSL_CTX_load_verify_locations(backend->ctx, ssl_cafile, ssl_capath)) {\n",
                            "      if(verifypeer && !imported_native_ca) {\n",
                            "        failf(data, \"error setting certificate verify locations:\\n\"\n",
                            "              \"  CAfile: %s\\n  CApath: %s\",\n",
                            "              ssl_cafile ? ssl_cafile : \"none\",\n",
                            "              ssl_capath ? ssl_capath : \"none\");\n",
                            "        return CURLE_SSL_CACERT_BADFILE;\n",
                            "      }\n",
                            "      infof(data, \"error setting certificate verify locations,\"\n",
                            "            \" continuing anyway:\\n\");\n",
                            "    }\n",
                            "    else {\n",
                            "      infof(data, \"successfully set certificate verify locations:\\n\");\n",
                            "    }\n",
                            "    infof(data,\n",
                            "          \"  CAfile: %s\\n\"\n",
                            "          \"  CApath: %s\\n\",\n",
                            "          ssl_cafile ? ssl_cafile : \"none\",\n",
                            "          ssl_capath ? ssl_capath : \"none\");\n",
                            "  }\n",
                            "#endif\n",
                            "#ifdef CURL_CA_FALLBACK\n",
                            "  if(verifypeer && !ssl_cafile && !ssl_capath && !imported_native_ca) {\n",
                            "    SSL_CTX_set_default_verify_paths(backend->ctx);\n",
                            "  }\n",
                            "#endif\n",
                            "  if(ssl_crlfile) {\n",
                            "    lookup = X509_STORE_add_lookup(SSL_CTX_get_cert_store(backend->ctx),\n",
                            "                                 X509_LOOKUP_file());\n",
                            "    if(!lookup ||\n",
                            "       (!X509_load_crl_file(lookup, ssl_crlfile, X509_FILETYPE_PEM)) ) {\n",
                            "      failf(data, \"error loading CRL file: %s\", ssl_crlfile);\n",
                            "      return CURLE_SSL_CRL_BADFILE;\n",
                            "    }\n",
                            "    infof(data, \"successfully load CRL file:\\n\");\n",
                            "    X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),\n",
                            "                         X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);\n",
                            "    infof(data, \"  CRLfile: %s\\n\", ssl_crlfile);\n",
                            "  }\n",
                            "  if(verifypeer) {\n",
                            "#if defined(X509_V_FLAG_TRUSTED_FIRST)\n",
                            "    X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),\n",
                            "                         X509_V_FLAG_TRUSTED_FIRST);\n",
                            "#endif\n",
                            "#ifdef X509_V_FLAG_PARTIAL_CHAIN\n",
                            "    if(!SSL_SET_OPTION(no_partialchain) && !ssl_crlfile) {\n",
                            "      X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),\n",
                            "                           X509_V_FLAG_PARTIAL_CHAIN);\n",
                            "    }\n",
                            "#endif\n",
                            "  }\n",
                            "  SSL_CTX_set_verify(backend->ctx,\n",
                            "                     verifypeer ? SSL_VERIFY_PEER : SSL_VERIFY_NONE, NULL);\n",
                            "#ifdef HAVE_KEYLOG_CALLBACK\n",
                            "  if(Curl_tls_keylog_enabled()) {\n",
                            "    SSL_CTX_set_keylog_callback(backend->ctx, ossl_keylog_callback);\n",
                            "  }\n",
                            "#endif\n",
                            "  SSL_CTX_set_session_cache_mode(backend->ctx,\n",
                            "      SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL);\n",
                            "  SSL_CTX_sess_set_new_cb(backend->ctx, ossl_new_session_cb);\n",
                            "  if(data->set.ssl.fsslctx) {\n",
                            "    Curl_set_in_callback(data, true);\n",
                            "    result = (*data->set.ssl.fsslctx)(data, backend->ctx,\n",
                            "                                      data->set.ssl.fsslctxp);\n",
                            "    Curl_set_in_callback(data, false);\n",
                            "    if(result) {\n",
                            "      failf(data, \"error signaled by ssl ctx callback\");\n",
                            "      return result;\n",
                            "    }\n",
                            "  }\n",
                            "  if(backend->handle)\n",
                            "    SSL_free(backend->handle);\n",
                            "  backend->handle = SSL_new(backend->ctx);\n",
                            "  if(!backend->handle) {\n",
                            "    failf(data, \"SSL: couldn't create a context (handle)!\");\n",
                            "    return CURLE_OUT_OF_MEMORY;\n",
                            "  }\n",
                            "#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \\\n",
                            "    !defined(OPENSSL_NO_OCSP)\n",
                            "  if(SSL_CONN_CONFIG(verifystatus))\n",
                            "    SSL_set_tlsext_status_type(backend->handle, TLSEXT_STATUSTYPE_ocsp);\n",
                            "#endif\n",
                            "#if defined(OPENSSL_IS_BORINGSSL) && defined(ALLOW_RENEG)\n",
                            "  SSL_set_renegotiate_mode(backend->handle, ssl_renegotiate_freely);\n",
                            "#endif\n",
                            "  SSL_set_connect_state(backend->handle);\n",
                            "  backend->server_cert = 0x0;\n",
                            "#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n",
                            "  if((0 == Curl_inet_pton(AF_INET, hostname, &addr)) &&\n",
                            "#ifdef ENABLE_IPV6\n",
                            "     (0 == Curl_inet_pton(AF_INET6, hostname, &addr)) &&\n",
                            "#endif\n",
                            "     sni &&\n",
                            "     !SSL_set_tlsext_host_name(backend->handle, hostname))\n",
                            "    infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n",
                            "          \"TLS extension\\n\");\n",
                            "#endif\n",
                            "  if(SSL_SET_OPTION(primary.sessionid)) {\n",
                            "    void *ssl_sessionid = NULL;\n",
                            "    int connectdata_idx = ossl_get_ssl_conn_index();\n",
                            "    int sockindex_idx = ossl_get_ssl_sockindex_index();\n",
                            "    if(connectdata_idx >= 0 && sockindex_idx >= 0) {\n",
                            "      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n",
                            "      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n",
                            "    }\n",
                            "    Curl_ssl_sessionid_lock(conn);\n",
                            "    if(!Curl_ssl_getsessionid(conn, &ssl_sessionid, NULL, sockindex)) {\n",
                            "      if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n",
                            "        Curl_ssl_sessionid_unlock(conn);\n",
                            "        failf(data, \"SSL: SSL_set_session failed: %s\",\n",
                            "              ossl_strerror(ERR_get_error(), error_buffer,\n",
                            "                            sizeof(error_buffer)));\n",
                            "        return CURLE_SSL_CONNECT_ERROR;\n",
                            "      }\n",
                            "      infof(data, \"SSL re-using session ID\\n\");\n",
                            "    }\n",
                            "    Curl_ssl_sessionid_unlock(conn);\n",
                            "  }\n",
                            "#ifndef CURL_DISABLE_PROXY\n",
                            "  if(conn->proxy_ssl[sockindex].use) {\n",
                            "    BIO *const bio = BIO_new(BIO_f_ssl());\n",
                            "    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;\n",
                            "    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);\n",
                            "    DEBUGASSERT(handle != NULL);\n",
                            "    DEBUGASSERT(bio != NULL);\n",
                            "    BIO_set_ssl(bio, handle, FALSE);\n",
                            "    SSL_set_bio(backend->handle, bio, bio);\n",
                            "  }\n",
                            "  else\n",
                            "#endif\n"
                        ]
                    }
                ],
                [
                    "Seg_0",
                    {
                        "Edit": "add",
                        "add_location": 2467,
                        "add_hunk": [
                            "  void *ssl_sessionid = NULL;\n"
                        ]
                    }
                ],
                [
                    "Seg_2",
                    {
                        "Edit": "add",
                        "add_location": 3160,
                        "add_hunk": [
                            "  }\n"
                        ]
                    }
                ],
                [
                    "Seg_4",
                    {
                        "Edit": "change",
                        "add_location": 3166,
                        "add_hunk": [
                            "if(conn->proxy_ssl[sockindex].use) {"
                        ],
                        "delete_location": [
                            3166,
                            3166
                        ],
                        "delete_hunk": [
                            "                            sizeof(error_buffer)));\n"
                        ]
                    }
                ],
                [
                    "Seg_5",
                    {
                        "Edit": "delete",
                        "delete_location": [
                            3171,
                            3176
                        ],
                        "delete_hunk": [
                            "    }\n",
                            "    Curl_ssl_sessionid_unlock(conn);\n",
                            "  }\n",
                            "#ifndef CURL_DISABLE_PROXY\n",
                            "  if(conn->proxy_ssl[sockindex].use) {\n"
                        ]
                    }
                ],
                [
                    "Seg_6",
                    {
                        "Edit": "add",
                        "add_location": 3177,
                        "add_hunk": [
                            "  Curl_ssl_sessionid_unlock(data);\n"
                        ]
                    }
                ],
                [
                    "Seg_7",
                    {
                        "Edit": "add",
                        "add_location": 4420,
                        "add_hunk": [
                            "static void ossl_associate_connection(struct Curl_easy *data,struct connectdata *conn,int sockindex)\n",
                            "{\n",
                            "  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n",
                            "  struct ssl_backend_data *backend = connssl->backend;\n",
                            "  if(!backend->handle)\n",
                            "    return;\n",
                            "  if(SSL_SET_OPTION(primary.sessionid)) {\n",
                            "    int data_idx = ossl_get_ssl_data_index();\n",
                            "    int connectdata_idx = ossl_get_ssl_conn_index();\n",
                            "    int sockindex_idx = ossl_get_ssl_sockindex_index();\n",
                            "    int proxy_idx = ossl_get_proxy_index();\n",
                            "    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 && proxy_idx >= 0) {\n",
                            "      SSL_set_ex_data(backend->handle, data_idx, data);\n",
                            "      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n",
                            "      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n",
                            "#ifndef CURL_DISABLE_PROXY\n",
                            "      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:NULL);\n",
                            "#else\n",
                            "      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n",
                            "#endif\n",
                            "    }\n",
                            "  }\n",
                            "}\n",
                            "static void ossl_disassociate_connection(struct Curl_easy *data, int sockindex)\n",
                            "{\n",
                            "  struct connectdata *conn = data->conn;\n",
                            "  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n",
                            "  struct ssl_backend_data *backend = connssl->backend;\n",
                            "  if(!backend->handle)\n",
                            "    return;\n",
                            "  if(SSL_SET_OPTION(primary.sessionid)) {\n",
                            "    bool isproxy = FALSE;\n",
                            "    bool incache;\n",
                            "    void *old_ssl_sessionid = NULL;\n",
                            "    int data_idx = ossl_get_ssl_data_index();\n",
                            "    int connectdata_idx = ossl_get_ssl_conn_index();\n",
                            "    int sockindex_idx = ossl_get_ssl_sockindex_index();\n",
                            "    int proxy_idx = ossl_get_proxy_index();\n",
                            "    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 && proxy_idx >= 0) {\n",
                            "      isproxy = SSL_get_ex_data(backend->handle, proxy_idx) ? TRUE : FALSE;\n",
                            "      SSL_set_ex_data(backend->handle, data_idx, NULL);\n",
                            "      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);\n",
                            "      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);\n",
                            "      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n",
                            "    }\n",
                            "    Curl_ssl_sessionid_lock(data);\n",
                            "    incache = !(Curl_ssl_getsessionid(data, conn, isproxy,&old_ssl_sessionid, NULL, sockindex));\n",
                            "    if(incache)\n",
                            "      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n",
                            "    Curl_ssl_sessionid_unlock(data);\n",
                            "  }\n",
                            "}\n"
                        ]
                    }
                ],
                [
                    "Seg_8",
                    {
                        "Edit": "change",
                        "add_location": 4425,
                        "add_hunk": [
                            "  SSLSUPP_TLS13_CIPHERSUITES |#endifSSLSUPP_HTTPS_PROXY,sizeof(struct ssl_backend_data),ossl_init,/* init */ossl_cleanup, /* cleanup */ossl_version, /* version */ossl_check_cxn, /* check_cxn */ossl_shutdown,/* shutdown */ossl_data_pending,/* data_pending */ossl_random,/* random */ossl_cert_status_request, /* cert_status_request */ossl_connect, /* connect */ossl_connect_nonblocking, /* connect_nonblocking */Curl_ssl_getsock, /* getsock */ossl_get_internals, /* get_internals */ossl_close, /* close_one */ossl_close_all, /* close_all */ossl_session_free,/* session_free */ossl_set_engine,/* set_engine */ossl_set_engine_default,/* set_engine_default */ossl_engines_list,/* engines_list */Curl_none_false_start,/* false_start */#if (OPENSSL_VERSION_NUMBER >= 0x0090800fL) && !defined(OPENSSL_NO_SHA256)#else#endif};\n"
                        ],
                        "delete_location": [
                            4425,
                            4455
                        ],
                        "delete_hunk": [
                            "  SSLSUPP_TLS13_CIPHERSUITES |\n",
                            "#endif\n",
                            "  SSLSUPP_HTTPS_PROXY,\n",
                            "  sizeof(struct ssl_backend_data),\n",
                            "  Curl_ossl_init,                /* init */\n",
                            "  Curl_ossl_cleanup,             /* cleanup */\n",
                            "  Curl_ossl_version,             /* version */\n",
                            "  Curl_ossl_check_cxn,           /* check_cxn */\n",
                            "  Curl_ossl_shutdown,            /* shutdown */\n",
                            "  Curl_ossl_data_pending,        /* data_pending */\n",
                            "  Curl_ossl_random,              /* random */\n",
                            "  Curl_ossl_cert_status_request, /* cert_status_request */\n",
                            "  Curl_ossl_connect,             /* connect */\n",
                            "  Curl_ossl_connect_nonblocking, /* connect_nonblocking */\n",
                            "  Curl_ossl_get_internals,       /* get_internals */\n",
                            "  Curl_ossl_close,               /* close_one */\n",
                            "  Curl_ossl_close_all,           /* close_all */\n",
                            "  Curl_ossl_session_free,        /* session_free */\n",
                            "  Curl_ossl_set_engine,          /* set_engine */\n",
                            "  Curl_ossl_set_engine_default,  /* set_engine_default */\n",
                            "  Curl_ossl_engines_list,        /* engines_list */\n",
                            "  Curl_none_false_start,         /* false_start */\n",
                            "  Curl_ossl_md5sum,              /* md5sum */\n",
                            "#if (OPENSSL_VERSION_NUMBER >= 0x0090800fL) && !defined(OPENSSL_NO_SHA256)\n",
                            "  Curl_ossl_sha256sum            /* sha256sum */\n",
                            "#else\n",
                            "  NULL                           /* sha256sum */\n",
                            "#endif\n",
                            "};\n"
                        ]
                    }
                ],
                [
                    "Seg_10",
                    {
                        "Edit": "add",
                        "add_location": 4457,
                        "add_hunk": [
                            "  NULL,                     /* sha256sum */\n",
                            "  ossl_associate_connection, /* associate_connection */\n",
                            "  ossl_disassociate_connection /* disassociate_connection */\n"
                        ]
                    }
                ]
            ],
            "semanic_check": {
                "Syntax: ossl_check_cxn -> ossl_connect_step1": {
                    "PDG_Mapping": "PDG Mapping Failed: Cannot load pdg dot file from pb and pc"
                },
                "Coarse:[Pa_Macro_Definition]||[Pc_Macro_Definition]": {
                    "Seg_7": {
                        "type": "out func",
                        "state": "success",
                        "info": "src:function"
                    },
                    "Seg_8": {
                        "type": "out func",
                        "state": "success",
                        "info": [
                            "unknown",
                            "cpp:directive",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "unknown",
                            "cpp:directive",
                            "unknown",
                            "cpp:directive",
                            "unknown",
                            "cpp:directive",
                            "unknown"
                        ]
                    },
                    "Seg_9": {
                        "type": "out func",
                        "state": "success",
                        "info": "unknown"
                    },
                    "Seg_10": {
                        "type": "out func",
                        "state": "success",
                        "info": "unknown"
                    }
                }
            },
            "verify_patch": null,
            "patch_types": [
                "other",
                "function_call",
                "change_type",
                "sanity_check",
                "function_definition",
                "outside"
            ]
        }
    }
}